var searchIndex = {};
searchIndex["gearley"] = {"doc":"","items":[[0,"events","gearley","",null,null],[3,"RawPredictedItems","gearley::events","",null,null],[3,"PredictionEvents","","",null,null],[3,"MedialEvents","","",null,null],[3,"Events","","",null,null],[3,"Distances","","",null,null],[3,"Tracing","","",null,null],[3,"ExpectedTerminals","","",null,null],[6,"RawMedialItems","","",null,null],[11,"new","","",0,{"inputs":[{"name":"iter"}],"output":{"name":"self"}}],[11,"next","","",0,{"inputs":[{"name":"rawpredicteditems"}],"output":{"name":"option"}}],[11,"next","","",1,{"inputs":[{"name":"predictionevents"}],"output":{"name":"option"}}],[11,"next","","",2,{"inputs":[{"name":"medialevents"}],"output":{"name":"option"}}],[11,"next","","",3,{"inputs":[{"name":"events"}],"output":{"name":"option"}}],[11,"next","","",4,{"inputs":[{"name":"distances"}],"output":{"name":"option"}}],[11,"next","","",5,{"inputs":[{"name":"tracing"}],"output":{"name":"option"}}],[11,"next","","",6,{"inputs":[{"name":"expectedterminals"}],"output":{"name":"option"}}],[0,"forest","gearley","",null,null],[3,"Traversal","gearley::forest","",null,null],[0,"depth_first","","",null,null],[3,"ActionClosureEvaluator","gearley::forest::depth_first","",null,null],[3,"ArrayEvaluator","","",null,null],[3,"ValueArray","","",null,null],[3,"SumHandle","","",null,null],[12,"node","","",7,null],[12,"summands","","",7,null],[12,"factor_stack","","",7,null],[12,"grammar","","",7,null],[3,"LeafHandle","","",null,null],[12,"factor","","",8,null],[12,"terminal","","",8,null],[12,"value","","",8,null],[3,"NullHandle","","",null,null],[12,"factor","","",9,null],[12,"symbol","","",9,null],[3,"Traversal","","",null,null],[3,"SumBuilder","","",null,null],[3,"Bocage","","",null,null],[4,"TraversalBottom","","",null,null],[13,"Leaf","","",10,null],[13,"Null","","",10,null],[11,"new","","",11,{"inputs":[{"name":"f"},{"name":"g"},{"name":"h"}],"output":{"name":"self"}}],[11,"new","","",12,{"inputs":[],"output":{"name":"self"}}],[11,"build_slice","","",12,{"inputs":[{"name":"valuearray"},{"name":"usize"}],"output":{"name":"slicebuilder"}}],[11,"new","","",13,{"inputs":[{"name":"valuearray"},{"name":"e"}],"output":{"name":"self"}}],[11,"traverse","","",13,null],[0,"cartesian_product","","",null,null],[3,"Factor","gearley::forest::depth_first::cartesian_product","",null,null],[3,"CartesianProduct","","",null,null],[11,"new","","",14,{"inputs":[],"output":{"name":"self"}}],[11,"from_production","","Initialize the cartesian product from a production.",14,{"inputs":[{"name":"cartesianproduct"},{"name":"producthandle"}],"output":null}],[11,"as_slice","","",14,null],[11,"next","","",14,{"inputs":[{"name":"cartesianproduct"}],"output":{"name":"option"}}],[11,"result","gearley::forest::depth_first","",7,null],[11,"result","","",8,null],[11,"result","","",9,null],[11,"iter","","Iterate through productions that are summed by this node.",7,{"inputs":[{"name":"sumhandle"}],"output":{"name":"sumiter"}}],[11,"nonterminal","","Get the nonterminal symbol of this node.",7,{"inputs":[{"name":"sumhandle"}],"output":{"name":"symbol"}}],[0,"order","","",null,null],[3,"NullOrder","gearley::forest::depth_first::order","",null,null],[8,"Order","","",null,null],[11,"sum","","Apply the order to sum node alternatives.",15,null],[11,"product","","Apply the order to product node factors.",15,null],[11,"new","","",16,{"inputs":[],"output":{"name":"self"}}],[0,"node","gearley::forest::depth_first","",null,null],[3,"Node","gearley::forest::depth_first::node","",null,null],[3,"Factors","","",null,null],[12,"left","","",17,null],[12,"right","","",17,null],[4,"NodeInner","","",null,null],[13,"Sum","","",18,null],[12,"summands","gearley::forest::depth_first::node::NodeInner","Invariant: This slice is not empty.\nInvariant: This slice directly contains only `Product` or `ShallowProduct`.\n(GADTs would be useful here)",18,null],[13,"Product","gearley::forest::depth_first::node","",18,null],[12,"action","gearley::forest::depth_first::node::NodeInner","",18,null],[12,"factors","","",18,null],[13,"Leaf","gearley::forest::depth_first::node","",18,null],[12,"symbol","gearley::forest::depth_first::node::NodeInner","",18,null],[13,"LeafWithValue","gearley::forest::depth_first::node","",18,null],[12,"symbol","gearley::forest::depth_first::node::NodeInner","",18,null],[12,"value","","",18,null],[13,"Evaluated","gearley::forest::depth_first::node","",18,null],[12,"values","gearley::forest::depth_first::node::NodeInner","The type depends on `symbol`\nWe need HKT to express this neatly",18,null],[13,"ShallowProduct","gearley::forest::depth_first::node","",18,null],[12,"action","gearley::forest::depth_first::node::NodeInner","",18,null],[12,"factor_stack_bottom","","",18,null],[11,"fmt","gearley::forest::depth_first::node","",19,{"inputs":[{"name":"node"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",18,{"inputs":[{"name":"nodeinner"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",17,{"inputs":[{"name":"factors"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",19,{"inputs":[{"name":"node"}],"output":{"name":"self"}}],[11,"clone","","",18,{"inputs":[{"name":"nodeinner"}],"output":{"name":"self"}}],[11,"clone","","",17,{"inputs":[{"name":"factors"}],"output":{"name":"self"}}],[11,"nonterminal","","",19,{"inputs":[{"name":"node"},{"name":"internalgrammar"}],"output":{"name":"u32"}}],[11,"factor_stack_bottom","","",19,{"inputs":[{"name":"node"}],"output":{"name":"option"}}],[11,"alternatives","","",19,null],[11,"get","","",19,{"inputs":[{"name":"node"}],"output":{"name":"nodeinner"}}],[11,"set","","",19,{"inputs":[{"name":"node"},{"name":"nodeinner"}],"output":null}],[11,"into","","",18,{"inputs":[{"name":"nodeinner"}],"output":{"name":"node"}}],[11,"new","gearley::forest::depth_first","",20,{"inputs":[{"name":"arena"},{"name":"usize"}],"output":{"name":"self"}}],[11,"push","","",20,{"inputs":[{"name":"sumbuilder"},{"name":"completeditem"}],"output":null}],[11,"sum","","",20,{"inputs":[{"name":"sumbuilder"},{"name":"u32"}],"output":{"name":"noderef"}}],[11,"reserve","","",20,{"inputs":[{"name":"sumbuilder"},{"name":"usize"}],"output":null}],[11,"new","gearley::forest","",21,{"inputs":[{"name":"bocage"},{"name":"o"}],"output":{"name":"self"}}],[11,"traverse","","",21,{"inputs":[{"name":"traversal"},{"name":"noderef"}],"output":null}],[11,"traverse_deps","","",21,{"inputs":[{"name":"traversal"}],"output":{"name":"option"}}],[11,"traverse_sum","","",21,{"inputs":[{"name":"traversal"}],"output":{"name":"traversesum"}}],[11,"finish","","",21,null],[6,"NodeRef","gearley::forest::depth_first","",null,null],[11,"new","","",22,{"inputs":[{"name":"internalgrammar"}],"output":{"name":"self"}}],[11,"initialize","","",22,{"inputs":[{"name":"bocage"}],"output":null}],[11,"build","","",22,{"inputs":[{"name":"bocage"},{"name":"usize"}],"output":{"name":"nodebuilder"}}],[11,"leaf","","",22,{"inputs":[{"name":"bocage"},{"name":"symbol"},{"name":"u32"},{"name":"leafvalue"}],"output":{"name":"noderef"}}],[11,"nulling","","",22,{"inputs":[{"name":"bocage"},{"name":"symbol"}],"output":{"name":"noderef"}}],[0,"null_forest","gearley::forest","",null,null],[3,"NullForest","gearley::forest::null_forest","An empty forest.",null,null],[3,"NullBuilder","","",null,null],[11,"build","","",23,{"inputs":[{"name":"nullforest"},{"name":"usize"}],"output":{"name":"nullbuilder"}}],[11,"leaf","","",23,null],[11,"nulling","","",23,{"inputs":[{"name":"nullforest"},{"name":"symbol"}],"output":null}],[11,"push","","",24,{"inputs":[{"name":"nullbuilder"},{"name":"completeditem"}],"output":null}],[11,"sum","","",24,{"inputs":[{"name":"nullbuilder"},{"name":"u32"}],"output":{"name":"noderef"}}],[11,"reserve","","",24,{"inputs":[{"name":"nullbuilder"},{"name":"usize"}],"output":null}],[8,"Forest","gearley::forest","",null,null],[16,"NodeRef","","Reference to a node.",25,null],[16,"NodeBuilder","","",25,null],[16,"LeafValue","","",25,null],[10,"build","","",25,{"inputs":[{"name":"forest"},{"name":"usize"}],"output":{"name":"nodebuilder"}}],[10,"leaf","","",25,{"inputs":[{"name":"forest"},{"name":"symbol"},{"name":"u32"},{"name":"leafvalue"}],"output":{"name":"noderef"}}],[10,"nulling","","",25,{"inputs":[{"name":"forest"},{"name":"symbol"}],"output":{"name":"noderef"}}],[8,"NodeBuilder","","",null,null],[16,"NodeRef","","",26,null],[10,"push","","",26,{"inputs":[{"name":"nodebuilder"},{"name":"completeditem"}],"output":null}],[10,"sum","","",26,{"inputs":[{"name":"nodebuilder"},{"name":"u32"}],"output":{"name":"noderef"}}],[10,"reserve","","",26,{"inputs":[{"name":"nodebuilder"},{"name":"usize"}],"output":null}],[0,"grammar","gearley","",null,null],[3,"Grammar","gearley::grammar","Drop-in replacement for cfg::Cfg that traces relations between user-provided\nand internal grammars.",null,null],[3,"BinarizedGrammar","","",null,null],[3,"BuildHistory","","Default history.",null,null],[3,"PredictionTransition","","",null,null],[12,"symbol","","",27,null],[12,"dot","","",27,null],[3,"InternalGrammar","","",null,null],[3,"InternalGrammarParts","","",null,null],[12,"storage","","",28,null],[12,"num_syms","","",28,null],[12,"num_rules","","",28,null],[12,"num_internal_syms","","",28,null],[12,"num_external_syms","","",28,null],[12,"num_nulling_intermediate","","",28,null],[12,"start_sym","","",28,null],[12,"trivial_derivation","","",28,null],[3,"InternalGrammarSlices","","",null,null],[12,"inverse_prediction","","",29,null],[12,"inverse_prediction_index","","",29,null],[12,"events_prediction","","",29,null],[12,"events1","","",29,null],[12,"events2","","",29,null],[12,"eval","","",29,null],[12,"rules","","",29,null],[12,"tracing_pred","","",29,null],[12,"nulling_eliminated","","",29,null],[12,"tracing","","",29,null],[12,"to_internal","","",29,null],[3,"InternalGrammarSlicesMut","","",null,null],[12,"prediction_matrix","","",30,null],[12,"inverse_prediction","","",30,null],[12,"inverse_prediction_index","","",30,null],[12,"events_pred","","",30,null],[12,"events1","","",30,null],[12,"events2","","",30,null],[12,"tracing_pred","","",30,null],[12,"tracing","","",30,null],[12,"nulling_eliminated","","",30,null],[12,"rules","","",30,null],[12,"eval","","",30,null],[3,"History","","",null,null],[3,"RuleDot","","",null,null],[3,"BinaryRule","","",null,null],[3,"RuleSlices","","",null,null],[12,"lhs","","",31,null],[12,"rhs0","","",31,null],[12,"rhs1","","",31,null],[3,"RuleSlicesMut","","",null,null],[12,"lhs","","",32,null],[12,"rhs0","","",32,null],[12,"rhs1","","",32,null],[3,"Rules","","",null,null],[4,"DotKind","","",null,null],[13,"Medial","","",33,null],[13,"Completed","","",33,null],[6,"ExternalDottedRule","","",null,null],[6,"RuleOrigin","","",null,null],[6,"EventId","","",null,null],[6,"MinimalDistance","","",null,null],[6,"Event","","",null,null],[6,"NullingRule","","",null,null],[6,"NullingEliminated","","",null,null],[6,"NullingIntermediateRule","","",null,null],[11,"new","","",34,{"inputs":[],"output":{"name":"self"}}],[11,"set_start","","",34,{"inputs":[{"name":"grammar"},{"name":"symbol"}],"output":null}],[11,"get_start","","",34,{"inputs":[{"name":"grammar"}],"output":{"name":"symbol"}}],[11,"rule","","",34,{"inputs":[{"name":"grammar"},{"name":"symbol"}],"output":{"name":"rulebuilder"}}],[11,"sequence","","",34,{"inputs":[{"name":"grammar"},{"name":"symbol"}],"output":{"name":"sequencerulebuilder"}}],[11,"binarize","","",34,{"inputs":[{"name":"grammar"}],"output":{"name":"binarizedgrammar"}}],[11,"into_internal_grammar","","",34,{"inputs":[{"name":"grammar"}],"output":{"name":"internalgrammar"}}],[11,"new","cfg::grammar","Creates an empty context-free grammar.",35,{"inputs":[],"output":{"name":"cfg"}}],[11,"with_sym_source","","Creates an empty context-free grammar with the given symbol source.",35,{"inputs":[{"name":"symbolsource"}],"output":{"name":"cfg"}}],[11,"sym","","Returns generated symbols.",35,{"inputs":[{"name":"cfg"}],"output":{"name":"t"}}],[11,"next_sym","","Generates a new unique symbol.",35,{"inputs":[{"name":"cfg"}],"output":{"name":"symbol"}}],[11,"num_syms","","Returns the number of symbols in use.",35,{"inputs":[{"name":"cfg"}],"output":{"name":"usize"}}],[11,"sequence","","Starts building a sequence rule.",35,{"inputs":[{"name":"cfg"},{"name":"symbol"}],"output":{"name":"sequencerulebuilder"}}],[11,"sequence_rules","","Returns sequence rules.",35,null],[11,"rewrite_sequences","","Forces a rewrite of sequence rules into grammar rules.",35,null],[11,"binarize","","Returns a binarized grammar which is weakly equivalent to this grammar.",35,{"inputs":[{"name":"cfg"}],"output":{"name":"binarizedcfg"}}],[11,"sym_source","","",35,{"inputs":[{"name":"cfg"}],"output":{"name":"symbolsource"}}],[11,"sym_source_mut","","",35,{"inputs":[{"name":"cfg"}],"output":{"name":"symbolsource"}}],[11,"retain","","",35,null],[11,"add_rule","","",35,null],[11,"clone","","",35,{"inputs":[{"name":"cfg"}],"output":{"name":"cfg"}}],[11,"deref","gearley::grammar","",34,{"inputs":[{"name":"grammar"}],"output":{"name":"target"}}],[11,"deref_mut","","",34,{"inputs":[{"name":"grammar"}],"output":{"name":"target"}}],[11,"clone","","",36,{"inputs":[{"name":"binarizedgrammar"}],"output":{"name":"binarizedgrammar"}}],[11,"new","","",36,{"inputs":[],"output":{"name":"self"}}],[11,"set_start","","",36,{"inputs":[{"name":"binarizedgrammar"},{"name":"symbol"}],"output":null}],[11,"get_start","","",36,{"inputs":[{"name":"binarizedgrammar"}],"output":{"name":"symbol"}}],[11,"sym_source","cfg::binarized","",37,{"inputs":[{"name":"binarizedcfg"}],"output":{"name":"symbolsource"}}],[11,"sym_source_mut","","",37,{"inputs":[{"name":"binarizedcfg"}],"output":{"name":"symbolsource"}}],[11,"retain","","",37,null],[11,"add_rule","","",37,null],[11,"eliminate_nulling_rules","","Eliminates all rules of the form `A ::= epsilon`.",37,{"inputs":[{"name":"binarizedcfg"}],"output":{"name":"binarizedcfg"}}],[11,"sym","","Returns generated symbols.",37,{"inputs":[{"name":"binarizedcfg"}],"output":{"name":"t"}}],[11,"next_sym","","Generates a new unique symbol.",37,{"inputs":[{"name":"binarizedcfg"}],"output":{"name":"symbol"}}],[11,"num_syms","","Returns the number of symbols in use.",37,{"inputs":[{"name":"binarizedcfg"}],"output":{"name":"usize"}}],[11,"new","","Creates a BinarizedCfg.",37,{"inputs":[],"output":{"name":"binarizedcfg"}}],[11,"with_sym_source","","Creates an empty BinarizedCfg with the given symbol source.",37,{"inputs":[{"name":"symbolsource"}],"output":{"name":"binarizedcfg"}}],[11,"from_context_free","","Creates a BinarizedCfg by binarizing a context-free grammar.",37,{"inputs":[{"name":"g"}],"output":{"name":"binarizedcfg"}}],[11,"sort","","Sorts the rule array.",37,null],[11,"sort_by","","Sorts the rule array in place, using the argument to compare elements.",37,null],[11,"dedup","","Removes consecutive duplicate rules.",37,null],[11,"clone","","",37,{"inputs":[{"name":"binarizedcfg"}],"output":{"name":"binarizedcfg"}}],[11,"deref","gearley::grammar","",36,{"inputs":[{"name":"binarizedgrammar"}],"output":{"name":"target"}}],[11,"deref_mut","","",36,{"inputs":[{"name":"binarizedgrammar"}],"output":{"name":"target"}}],[11,"new","","Creates default history.",38,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"build","","",38,null],[11,"fmt","","",27,{"inputs":[{"name":"predictiontransition"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",27,{"inputs":[{"name":"predictiontransition"}],"output":{"name":"predictiontransition"}}],[11,"dot","","",27,{"inputs":[{"name":"predictiontransition"}],"output":{"name":"dotkind"}}],[11,"clone","","",39,{"inputs":[{"name":"internalgrammar"}],"output":{"name":"internalgrammar"}}],[11,"clone","","",28,{"inputs":[{"name":"internalgrammarparts"}],"output":{"name":"internalgrammarparts"}}],[11,"fmt","","",29,{"inputs":[{"name":"internalgrammarslices"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",40,{"inputs":[{"name":"history"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",40,{"inputs":[],"output":{"name":"history"}}],[11,"clone","","",40,{"inputs":[{"name":"history"}],"output":{"name":"history"}}],[11,"fmt","","",41,{"inputs":[{"name":"ruledot"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",41,{"inputs":[{"name":"ruledot"}],"output":{"name":"ruledot"}}],[11,"none","","",41,{"inputs":[],"output":{"name":"self"}}],[11,"trace","","",41,{"inputs":[{"name":"ruledot"}],"output":{"name":"option"}}],[11,"into","","",41,{"inputs":[{"name":"ruledot"}],"output":{"name":"event"}}],[11,"new","","",40,{"inputs":[{"name":"u32"},{"name":"usize"}],"output":{"name":"self"}}],[11,"origin","","",40,{"inputs":[{"name":"history"}],"output":{"name":"ruleorigin"}}],[11,"dots","","",40,null],[11,"no_op","","",40,{"inputs":[{"name":"history"}],"output":{"name":"self"}}],[11,"binarize","","",40,{"inputs":[{"name":"history"},{"name":"r"},{"name":"usize"}],"output":{"name":"self"}}],[11,"eliminate_nulling","","",40,{"inputs":[{"name":"history"},{"name":"r"},{"name":"binarizedrhssubset"}],"output":{"name":"self"}}],[11,"top","","",40,null],[11,"bottom","","",40,null],[11,"generate_special_start","","",36,{"inputs":[{"name":"binarizedgrammar"}],"output":{"name":"binarizedgrammar"}}],[11,"eliminate_nulling","","",36,null],[11,"process","","",36,null],[11,"from_grammar","","",39,{"inputs":[{"name":"grammar"}],"output":{"name":"self"}}],[11,"from_binarized_grammar","","",39,{"inputs":[{"name":"binarizedgrammar"}],"output":{"name":"self"}}],[11,"from_proper_binarized_grammar","","",39,{"inputs":[{"name":"binarizedgrammar"}],"output":{"name":"self"}}],[11,"from_processed_grammar","","",39,{"inputs":[{"name":"binarizedgrammar"},{"name":"binarizedgrammar"}],"output":{"name":"self"}}],[11,"from_processed_grammar_with_maps","","",39,{"inputs":[{"name":"binarizedgrammar"},{"name":"mapping"},{"name":"binarizedgrammar"}],"output":{"name":"self"}}],[11,"to_parts","","",39,{"inputs":[{"name":"internalgrammar"}],"output":{"name":"internalgrammarparts"}}],[11,"from_parts","","",39,{"inputs":[{"name":"internalgrammarparts"}],"output":{"name":"self"}}],[11,"as_slices_mut","","",39,{"inputs":[{"name":"internalgrammar"}],"output":{"name":"internalgrammarslicesmut"}}],[11,"as_slices","","",39,{"inputs":[{"name":"internalgrammar"}],"output":{"name":"internalgrammarslices"}}],[11,"prediction_matrix","","",39,{"inputs":[{"name":"internalgrammar"}],"output":{"name":"bitsubmatrix"}}],[11,"inverse_prediction","","",39,null],[11,"num_syms","","",39,{"inputs":[{"name":"internalgrammar"}],"output":{"name":"usize"}}],[11,"num_rules","","",39,{"inputs":[{"name":"internalgrammar"}],"output":{"name":"usize"}}],[11,"num_pos","","",39,{"inputs":[{"name":"internalgrammar"}],"output":{"name":"usize"}}],[11,"start_sym","","",39,{"inputs":[{"name":"internalgrammar"}],"output":{"name":"symbol"}}],[11,"has_trivial_derivation","","",39,{"inputs":[{"name":"internalgrammar"}],"output":{"name":"bool"}}],[11,"nulling","","",39,{"inputs":[{"name":"internalgrammar"},{"name":"u32"}],"output":{"name":"nullingeliminated"}}],[11,"events","","",39,null],[11,"trace","","",39,null],[11,"complete_over","","",39,{"inputs":[{"name":"internalgrammar"},{"name":"dot"},{"name":"symbol"}],"output":{"name":"bool"}}],[11,"rules","","",39,{"inputs":[{"name":"internalgrammar"}],"output":{"name":"ruleslices"}}],[11,"get_rhs0","","",39,{"inputs":[{"name":"internalgrammar"},{"name":"dot"}],"output":{"name":"symbol"}}],[11,"get_rhs1","","",39,{"inputs":[{"name":"internalgrammar"},{"name":"dot"}],"output":{"name":"option"}}],[11,"get_lhs","","",39,{"inputs":[{"name":"internalgrammar"},{"name":"dot"}],"output":{"name":"symbol"}}],[11,"get_eval","","",39,{"inputs":[{"name":"internalgrammar"},{"name":"dot"}],"output":{"name":"ruleorigin"}}],[11,"eliminated_nulling_intermediate","","",39,null],[11,"inverse_prediction_of","","",39,null],[11,"to_internal","","",39,{"inputs":[{"name":"internalgrammar"},{"name":"symbol"}],"output":{"name":"option"}}],[11,"to_external","","",39,{"inputs":[{"name":"internalgrammar"},{"name":"symbol"}],"output":{"name":"symbol"}}],[11,"lhs","","",42,{"inputs":[{"name":"binaryrule"}],"output":{"name":"symbol"}}],[11,"rhs0","","",42,{"inputs":[{"name":"binaryrule"}],"output":{"name":"symbol"}}],[11,"rhs1","","",42,{"inputs":[{"name":"binaryrule"}],"output":{"name":"option"}}],[11,"fmt","","",31,{"inputs":[{"name":"ruleslices"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"rules","","",31,{"inputs":[{"name":"ruleslices"}],"output":{"name":"rules"}}],[11,"next","","",43,{"inputs":[{"name":"rules"}],"output":{"name":"option"}}],[0,"item","gearley","",null,null],[3,"Item","gearley::item","",null,null],[12,"origin","","",44,null],[12,"dot","","",44,null],[12,"node","","",44,null],[3,"CompletedItem","","",null,null],[12,"dot","","The dot position.",45,null],[12,"origin","","The origin location.\nIt comes after `dot`, so that (origin, dot) can be compared in a single instruction\non little-endian systems.",45,null],[12,"left_node","","Left bocage node.",45,null],[12,"right_node","","Right bocage node.",45,null],[6,"Dot","","",null,null],[6,"Origin","","",null,null],[11,"eq","","",44,{"inputs":[{"name":"item"},{"name":"item"}],"output":{"name":"bool"}}],[11,"ne","","",44,{"inputs":[{"name":"item"},{"name":"item"}],"output":{"name":"bool"}}],[11,"fmt","","",44,{"inputs":[{"name":"item"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",44,{"inputs":[{"name":"item"}],"output":{"name":"item"}}],[11,"fmt","","",45,{"inputs":[{"name":"completeditem"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",45,{"inputs":[{"name":"completeditem"}],"output":{"name":"completeditem"}}],[11,"eq","","",45,{"inputs":[{"name":"completeditem"},{"name":"self"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",45,{"inputs":[{"name":"completeditem"},{"name":"self"}],"output":{"name":"option"}}],[11,"cmp","","",45,{"inputs":[{"name":"completeditem"},{"name":"self"}],"output":{"name":"ordering"}}],[0,"recognizer","gearley","",null,null],[3,"Recognizer","gearley::recognizer","The recognizer implements the Earley algorithm. It parses the given input according\nto the `grammar`. The `forest` is used to construct a parse result.",null,null],[3,"Completions","","A tool for completing items.",null,null],[3,"Completion","","A group of completed items.",null,null],[11,"new","","Creates a new recognizer for a given grammar and forest. The recognizer has an initial\nEarley set that predicts the grammar&#39;s start symbol.",46,{"inputs":[{"name":"internalgrammar"},{"name":"f"}],"output":{"name":"recognizer"}}],[11,"predict","","Makes the current Earley set predict a given symbol.",46,{"inputs":[{"name":"recognizer"},{"name":"symbol"}],"output":null}],[11,"scan","","Reads a token. Creates a leaf bocage node with the given value. After reading one or more\ntokens, the parse can be advanced.",46,{"inputs":[{"name":"recognizer"},{"name":"symbol"},{"name":"leafvalue"}],"output":null}],[11,"advance","","Advances the parse. Calling this method may set the finished node, which can be accessed\nthrough the `finished_node` method.",46,{"inputs":[{"name":"recognizer"}],"output":{"name":"bool"}}],[11,"advance_without_completion","","Advances the parse. Omits the completion pass, which should be done through\nthe `completions` method. Keep in mind that calling this method may not set\nthe finished node, which should be tracked externally.",46,{"inputs":[{"name":"recognizer"}],"output":null}],[11,"is_exhausted","","Checks whether the recognizer is exhausted. The recognizer is exhausted when it can&#39;t accept\nmore input.",46,{"inputs":[{"name":"recognizer"}],"output":{"name":"bool"}}],[11,"completions","","Provides access to completions, which can be used to perform a completion pass.",46,{"inputs":[{"name":"recognizer"}],"output":{"name":"completions"}}],[11,"complete","","Complete items.",46,{"inputs":[{"name":"recognizer"},{"name":"origin"},{"name":"symbol"},{"name":"noderef"}],"output":null}],[11,"reset","","Resets the recognizer to its initial state by removing all contents.",46,{"inputs":[{"name":"recognizer"}],"output":null}],[11,"is_finished","","Checks whether there is a valid parse that ends at the current\nposition.",46,{"inputs":[{"name":"recognizer"}],"output":{"name":"bool"}}],[11,"finished_node","","Retrieves the bocage node that represents the parse that has finished at the current\nlocation.",46,{"inputs":[{"name":"recognizer"}],"output":{"name":"noderef"}}],[11,"raw_predicted_items","","Accesses predicted items.",46,{"inputs":[{"name":"recognizer"}],"output":{"name":"rawpredicteditems"}}],[11,"raw_medial_items","","Accesses medial items.",46,{"inputs":[{"name":"recognizer"}],"output":{"name":"rawmedialitems"}}],[11,"earleme","","Returns the current location number.",46,{"inputs":[{"name":"recognizer"}],"output":{"name":"usize"}}],[11,"grammar","","Returns a reference to the internal grammar.",46,{"inputs":[{"name":"recognizer"}],"output":{"name":"internalgrammar"}}],[11,"next_completion","","Allows iteration through groups of completions that have unique symbol and origin.",47,{"inputs":[{"name":"completions"}],"output":{"name":"option"}}],[11,"complete_all","","Completes all items.",48,{"inputs":[{"name":"completion"}],"output":{"name":"noderef"}}],[11,"next","","Allows iteration through completed items.",48,{"inputs":[{"name":"completion"}],"output":{"name":"option"}}],[11,"push","","Includes an item in the completion.",48,{"inputs":[{"name":"completion"},{"name":"completeditem"}],"output":null}],[11,"complete","","Uses the completion to complete items in the recognizer.",48,{"inputs":[{"name":"completion"}],"output":{"name":"noderef"}}],[11,"origin","","Returns the origin location of this completion.",48,{"inputs":[{"name":"completion"}],"output":{"name":"origin"}}],[11,"symbol","","Returns the symbol of this completion.",48,{"inputs":[{"name":"completion"}],"output":{"name":"symbol"}}],[0,"util","gearley","",null,null],[5,"sort_and_dedup","gearley::util","",null,{"inputs":[{"name":"vec"},{"name":"usize"},{"name":"h"}],"output":null}],[5,"dedup","","",null,null],[0,"binary_heap","","A priority queue implemented with a binary heap.",null,null],[3,"BinaryHeap","gearley::util::binary_heap","A priority queue implemented with a binary heap.",null,null],[11,"clone","","",49,{"inputs":[{"name":"binaryheap"}],"output":{"name":"self"}}],[11,"clone_from","","",49,{"inputs":[{"name":"binaryheap"},{"name":"self"}],"output":null}],[11,"new","","Creates an empty `BinaryHeap` as a max-heap.",49,{"inputs":[],"output":{"name":"binaryheap"}}],[11,"with_capacity","","Creates an empty `BinaryHeap` with a specific capacity.\nThis preallocates enough memory for `capacity` elements,\nso that the `BinaryHeap` does not have to be reallocated\nuntil it contains at least that many values.",49,{"inputs":[{"name":"usize"}],"output":{"name":"binaryheap"}}],[11,"peek","","Returns the greatest item in the binary heap, or `None` if it is empty.",49,{"inputs":[{"name":"binaryheap"}],"output":{"name":"option"}}],[11,"capacity","","Returns the number of elements the binary heap can hold without reallocating.",49,{"inputs":[{"name":"binaryheap"}],"output":{"name":"usize"}}],[11,"reserve_exact","","Reserves the minimum capacity for exactly `additional` more elements to be inserted in the\ngiven `BinaryHeap`. Does nothing if the capacity is already sufficient.",49,{"inputs":[{"name":"binaryheap"},{"name":"usize"}],"output":null}],[11,"reserve","","Reserves capacity for at least `additional` more elements to be inserted in the\n`BinaryHeap`. The collection may reserve more space to avoid frequent reallocations.",49,{"inputs":[{"name":"binaryheap"},{"name":"usize"}],"output":null}],[11,"shrink_to_fit","","Discards as much additional capacity as possible.",49,{"inputs":[{"name":"binaryheap"}],"output":null}],[11,"pop","","Removes the greatest item from the binary heap and returns it, or `None` if it\nis empty.",49,{"inputs":[{"name":"binaryheap"}],"output":{"name":"option"}}],[11,"push","","Pushes an item onto the binary heap.",49,{"inputs":[{"name":"binaryheap"},{"name":"t"}],"output":null}],[11,"len","","Returns the length of the binary heap.",49,{"inputs":[{"name":"binaryheap"}],"output":{"name":"usize"}}],[11,"is_empty","","Checks if the binary heap is empty.",49,{"inputs":[{"name":"binaryheap"}],"output":{"name":"bool"}}],[11,"clear","","Drops all items from the binary heap.",49,{"inputs":[{"name":"binaryheap"}],"output":null}],[11,"as_data_slice","","",49,null],[11,"as_data_slice_mut","","",49,null],[11,"extend","","",49,{"inputs":[{"name":"binaryheap"},{"name":"i"}],"output":null}],[11,"extend","","",49,{"inputs":[{"name":"binaryheap"},{"name":"i"}],"output":null}],[0,"slice_builder","gearley::util","",null,null],[3,"SliceBuilder","gearley::util::slice_builder","",null,null],[11,"new","","",50,{"inputs":[{"name":"arena"},{"name":"usize"}],"output":{"name":"self"}}],[11,"push","","",50,{"inputs":[{"name":"slicebuilder"},{"name":"t"}],"output":null}],[11,"advance_slice","","",50,null],[11,"into_slice","","",50,null],[11,"uninit_len","","",50,{"inputs":[{"name":"slicebuilder"}],"output":{"name":"usize"}}],[11,"extend","","",50,null],[11,"reserve","","",50,{"inputs":[{"name":"slicebuilder"},{"name":"usize"}],"output":null}],[11,"trace","gearley::recognizer","",46,{"inputs":[{"name":"recognizer"}],"output":{"name":"tracing"}}],[11,"events","","",46,{"inputs":[{"name":"recognizer"}],"output":{"name":"events"}}],[11,"minimal_distances","","",46,{"inputs":[{"name":"recognizer"}],"output":{"name":"distances"}}],[11,"expected_terminals","","",46,{"inputs":[{"name":"recognizer"}],"output":{"name":"expectedterminals"}}]],"paths":[[3,"RawPredictedItems"],[3,"PredictionEvents"],[3,"MedialEvents"],[3,"Events"],[3,"Distances"],[3,"Tracing"],[3,"ExpectedTerminals"],[3,"SumHandle"],[3,"LeafHandle"],[3,"NullHandle"],[4,"TraversalBottom"],[3,"ActionClosureEvaluator"],[3,"ValueArray"],[3,"ArrayEvaluator"],[3,"CartesianProduct"],[8,"Order"],[3,"NullOrder"],[3,"Factors"],[4,"NodeInner"],[3,"Node"],[3,"SumBuilder"],[3,"Traversal"],[3,"Bocage"],[3,"NullForest"],[3,"NullBuilder"],[8,"Forest"],[8,"NodeBuilder"],[3,"PredictionTransition"],[3,"InternalGrammarParts"],[3,"InternalGrammarSlices"],[3,"InternalGrammarSlicesMut"],[3,"RuleSlices"],[3,"RuleSlicesMut"],[4,"DotKind"],[3,"Grammar"],[3,"Cfg"],[3,"BinarizedGrammar"],[3,"BinarizedCfg"],[3,"BuildHistory"],[3,"InternalGrammar"],[3,"History"],[3,"RuleDot"],[3,"BinaryRule"],[3,"Rules"],[3,"Item"],[3,"CompletedItem"],[3,"Recognizer"],[3,"Completions"],[3,"Completion"],[3,"BinaryHeap"],[3,"SliceBuilder"]]};
searchIndex["cfg"] = {"doc":"Library for manipulations on context-free grammars. Most transformations are abstracted over\ngrammar representations.","items":[[3,"BinarizedCfg","cfg","Representation for grammars where right-hand sides of all rules have at most two symbols.",null,null],[3,"Cfg","","Basic representation of context-free grammars.",null,null],[3,"Symbol","","A common grammar symbol type.",null,null],[11,"clone","","",0,{"inputs":[{"name":"binarizedcfg"}],"output":{"name":"binarizedcfg"}}],[11,"new","","Creates a BinarizedCfg.",0,{"inputs":[],"output":{"name":"self"}}],[11,"with_sym_source","","Creates an empty BinarizedCfg with the given symbol source.",0,{"inputs":[{"name":"symbolsource"}],"output":{"name":"self"}}],[11,"from_context_free","","Creates a BinarizedCfg by binarizing a context-free grammar.",0,{"inputs":[{"name":"g"}],"output":{"name":"binarizedcfg"}}],[11,"sort","","Sorts the rule array.",0,{"inputs":[{"name":"binarizedcfg"}],"output":null}],[11,"sort_by","","Sorts the rule array in place, using the argument to compare elements.",0,{"inputs":[{"name":"binarizedcfg"},{"name":"f"}],"output":null}],[11,"dedup","","Removes consecutive duplicate rules.",0,{"inputs":[{"name":"binarizedcfg"}],"output":null}],[11,"sym","","Returns generated symbols.",0,{"inputs":[{"name":"binarizedcfg"}],"output":{"name":"t"}}],[11,"next_sym","","Generates a new unique symbol.",0,{"inputs":[{"name":"binarizedcfg"}],"output":{"name":"symbol"}}],[11,"num_syms","","Returns the number of symbols in use.",0,{"inputs":[{"name":"binarizedcfg"}],"output":{"name":"usize"}}],[11,"eliminate_nulling_rules","","Eliminates all rules of the form `A ::= epsilon`.",0,{"inputs":[{"name":"binarizedcfg"}],"output":{"name":"binarizedcfg"}}],[11,"sym_source","","",0,{"inputs":[{"name":"binarizedcfg"}],"output":{"name":"symbolsource"}}],[11,"sym_source_mut","","",0,{"inputs":[{"name":"binarizedcfg"}],"output":{"name":"symbolsource"}}],[11,"retain","","",0,{"inputs":[{"name":"binarizedcfg"},{"name":"f"}],"output":null}],[11,"add_rule","","",0,null],[0,"cycles","","Cycle detection and elimination.",null,null],[3,"Cycles","cfg::cycles","Provides information about cycles among unit derivations in the grammar. There are two ways of\npruning cycles.",null,null],[3,"CycleParticipants","","An iterator over the grammar&#39;s useless rules.",null,null],[11,"new","","Analyzes the grammar&#39;s cycles.",1,{"inputs":[{"name":"g"}],"output":{"name":"cycles"}}],[11,"cycle_free","","Checks whether the grammar is cycle-free.",1,{"inputs":[{"name":"cycles"}],"output":{"name":"bool"}}],[11,"cycle_participants","","Iterates over rules that participate in a cycle.",1,{"inputs":[{"name":"cycles"}],"output":{"name":"cycleparticipants"}}],[11,"remove_cycles","","Removes all rules that participate in a cycle. Doesn&#39;t preserve the language represented\nby the grammar.",1,{"inputs":[{"name":"cycles"}],"output":null}],[11,"rewrite_cycles","","Rewrites all rules that participate in a cycle. Preserves the language represented\nby the grammar.",1,{"inputs":[{"name":"cycles"}],"output":null}],[11,"next","","",2,{"inputs":[{"name":"cycleparticipants"}],"output":{"name":"option"}}],[11,"clone","cfg","",3,{"inputs":[{"name":"cfg"}],"output":{"name":"cfg"}}],[11,"new","","Creates an empty context-free grammar.",3,{"inputs":[],"output":{"name":"self"}}],[11,"with_sym_source","","Creates an empty context-free grammar with the given symbol source.",3,{"inputs":[{"name":"symbolsource"}],"output":{"name":"self"}}],[11,"sym","","Returns generated symbols.",3,{"inputs":[{"name":"cfg"}],"output":{"name":"t"}}],[11,"next_sym","","Generates a new unique symbol.",3,{"inputs":[{"name":"cfg"}],"output":{"name":"symbol"}}],[11,"num_syms","","Returns the number of symbols in use.",3,{"inputs":[{"name":"cfg"}],"output":{"name":"usize"}}],[11,"sequence","","Starts building a sequence rule.",3,{"inputs":[{"name":"cfg"},{"name":"symbol"}],"output":{"name":"sequencerulebuilder"}}],[11,"sequence_rules","","Returns sequence rules.",3,null],[11,"rewrite_sequences","","Forces a rewrite of sequence rules into grammar rules.",3,{"inputs":[{"name":"cfg"}],"output":null}],[11,"binarize","","Returns a binarized grammar which is weakly equivalent to this grammar.",3,{"inputs":[{"name":"cfg"}],"output":{"name":"binarizedcfg"}}],[11,"sym_source","","",3,{"inputs":[{"name":"cfg"}],"output":{"name":"symbolsource"}}],[11,"sym_source_mut","","",3,{"inputs":[{"name":"cfg"}],"output":{"name":"symbolsource"}}],[11,"retain","","",3,{"inputs":[{"name":"cfg"},{"name":"f"}],"output":null}],[11,"add_rule","","",3,null],[0,"history","","Any data carried alongside a grammar rule can be its _history_. Rule histories may contain\nmore than semantic actions.",null,null],[3,"NullHistory","cfg::history","A history which carries no data. All operations on `NullHistory` are no-op.",null,null],[3,"CloneHistory","","Clone history.",null,null],[3,"DefaultHistory","","Factory of default histories.",null,null],[3,"NullHistorySource","","A source that only works for building NullHistory.",null,null],[4,"BinarizedRhsSubset","","Used to inform which symbols on a rule&#39;Symbol RHS are nullable, and will be eliminated.",null,null],[13,"Left","","The first of two symbols.",4,null],[13,"Right","","The second of two symbols.",4,null],[13,"All","","All 1 or 2 symbols. The rule is nullable.",4,null],[8,"Action","","Trait for history types that may have semantic actions.",null,null],[10,"no_op","","Returns a history with no-op semantic action.",5,{"inputs":[{"name":"action"}],"output":{"name":"self"}}],[8,"Binarize","","Trait for history types that allow the rule to be binarized.",null,null],[10,"binarize","","Returns a history. May record the binarization.",6,{"inputs":[{"name":"binarize"},{"name":"r"},{"name":"usize"}],"output":{"name":"self"}}],[8,"EliminateNulling","","Trait for history types that allow the rule to have nulling symbols\neliminated from the RHS.",null,null],[10,"eliminate_nulling","","Returns a history. May record the elimination.",7,{"inputs":[{"name":"eliminatenulling"},{"name":"r"},{"name":"binarizedrhssubset"}],"output":{"name":"self"}}],[8,"AssignPrecedence","","Trait for history types that allow the rule to have its precedence assigned.",null,null],[10,"assign_precedence","","Returns a history. May record the precedence.",8,{"inputs":[{"name":"assignprecedence"},{"name":"r"},{"name":"u32"}],"output":{"name":"self"}}],[8,"RewriteSequence","","Trait for history types that allow the sequence rule to be rewritten into grammar rules.",null,null],[16,"Rewritten","","Must be an `Action`, because all created grammar rules except the topmost one will have\nno-op semantic action.",9,null],[10,"top","","Returns a history. May record the rewrite.",9,null],[10,"bottom","","Returns a history. May record the rewrite.",9,null],[8,"HistorySource","","A trait for history factories.",null,null],[10,"build","","Create a history.",10,null],[11,"clone","","",4,{"inputs":[{"name":"binarizedrhssubset"}],"output":{"name":"binarizedrhssubset"}}],[11,"default","","",11,{"inputs":[],"output":{"name":"nullhistory"}}],[11,"fmt","","",11,{"inputs":[{"name":"nullhistory"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",11,{"inputs":[{"name":"nullhistory"}],"output":{"name":"nullhistory"}}],[11,"no_op","","",11,{"inputs":[{"name":"nullhistory"}],"output":{"name":"self"}}],[11,"binarize","","",11,{"inputs":[{"name":"nullhistory"},{"name":"r"},{"name":"usize"}],"output":{"name":"self"}}],[11,"eliminate_nulling","","",11,{"inputs":[{"name":"nullhistory"},{"name":"r"},{"name":"binarizedrhssubset"}],"output":{"name":"self"}}],[11,"assign_precedence","","",11,{"inputs":[{"name":"nullhistory"},{"name":"r"},{"name":"u32"}],"output":{"name":"self"}}],[11,"top","","",11,null],[11,"bottom","","",11,null],[11,"new","","Creates a cloned history factory.",12,{"inputs":[{"name":"h"}],"output":{"name":"self"}}],[11,"build","","",12,null],[11,"new","","Creates a default history factory.",13,{"inputs":[],"output":{"name":"self"}}],[11,"build","","",13,null],[11,"clone","","",14,{"inputs":[{"name":"nullhistorysource"}],"output":{"name":"nullhistorysource"}}],[11,"build","","",14,null],[0,"precedence","cfg","Precedenced rules are built with the builder pattern.",null,null],[3,"PrecedencedRuleBuilder","cfg::precedence","Precedenced rules are built in series of rule alternatives with equal precedence.",null,null],[4,"Associativity","","Specifies the associativity of an operator.",null,null],[13,"Left","","Left associative.",15,null],[13,"Right","","Right associative.",15,null],[13,"Group","","`Group` usually means the operand is delimited, e.g. by parentheses.",15,null],[11,"eq","","",15,{"inputs":[{"name":"associativity"},{"name":"associativity"}],"output":{"name":"bool"}}],[11,"clone","","",15,{"inputs":[{"name":"associativity"}],"output":{"name":"associativity"}}],[11,"new","","Returns a precedenced rule builder.",16,{"inputs":[{"name":"d"},{"name":"symbol"}],"output":{"name":"self"}}],[11,"default_history","","Sets the default history source.",16,{"inputs":[{"name":"precedencedrulebuilder"},{"name":"hs2"}],"output":{"name":"precedencedrulebuilder"}}],[11,"precedenced_rule","","Starts building a new precedenced rule. The differences in precedence among rules only\nmatter within a particular precedenced rule.",16,{"inputs":[{"name":"precedencedrulebuilder"},{"name":"symbol"}],"output":{"name":"precedencedrulebuilder"}}],[11,"rule","","Starts building a new grammar rule.",16,{"inputs":[{"name":"precedencedrulebuilder"},{"name":"symbol"}],"output":{"name":"rulebuilder"}}],[11,"history","","Assigns the rule history, which is used on the next call to `rhs`, unless overwritten by\na call to `rhs_with_history`.",16,{"inputs":[{"name":"precedencedrulebuilder"},{"name":"history"}],"output":{"name":"self"}}],[11,"rhs","","Creates a rule alternative. If history wasn&#39;t provided, the rule has the `Default` history.",16,{"inputs":[{"name":"precedencedrulebuilder"},{"name":"s"}],"output":{"name":"self"}}],[11,"rhs_with_history","","Creates a rule alternative with the given RHS and history.",16,{"inputs":[{"name":"precedencedrulebuilder"},{"name":"s"},{"name":"history"}],"output":{"name":"self"}}],[11,"associativity","","Assigns the associativity, which influences the next call to `rhs` or `rhs_with_history`.",16,{"inputs":[{"name":"precedencedrulebuilder"},{"name":"associativity"}],"output":{"name":"self"}}],[11,"lower_precedence","","Assigns lower precedence to rule alternatives that are built after this call.",16,{"inputs":[{"name":"precedencedrulebuilder"}],"output":{"name":"self"}}],[11,"drop","","",16,{"inputs":[{"name":"precedencedrulebuilder"}],"output":null}],[0,"prediction","cfg","Prediction for predictive parsers.",null,null],[3,"MinimalDistance","cfg::prediction","Calculation of minimum distance from one part of the grammar to another.\nSimilar to multi-source shortest path search in a graph.",null,null],[3,"FirstSets","","FIRST sets.",null,null],[3,"FollowSets","","FOLLOW sets.",null,null],[11,"new","","Returns a new `MinimalDistance` for a grammar.",17,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"distances","","Returns distances in order respective to the order of rule iteration.",17,null],[11,"minimal_distances","","Calculates minimal distance from one parts of the grammar to others.\nReturns distances in order respective to the order of rule iteration.",17,null],[11,"new","","Compute all FIRST sets of the grammar.",18,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"first_sets","","Returns a reference to FIRST sets.",18,{"inputs":[{"name":"firstsets"}],"output":{"name":"persymbolsets"}}],[11,"new","","Compute all FOLLOW sets of the grammar.\nReturns FollowSets.",19,{"inputs":[{"name":"g"},{"name":"symbol"},{"name":"firstsets"}],"output":{"name":"self"}}],[11,"follow_sets","","Returns a reference to FOLLOW sets.",19,{"inputs":[{"name":"followsets"}],"output":{"name":"persymbolsets"}}],[6,"PerSymbolSets","","The representation of FIRST and FOLLOW sets.",null,null],[0,"remap","cfg","Remaps symbols and removes unused symbols.",null,null],[3,"Remap","cfg::remap","Remaps symbols and removes unused symbols.",null,null],[3,"Mapping","","Contains maps for translation between internal and external symbols.",null,null],[12,"to_internal","","An array of internal symbols, indexed by external symbol ID.",20,null],[12,"to_external","","An array of external symbols, indexed by internal symbol ID.",20,null],[11,"new","","Creates `Remap` to record information about remapped symbols.",21,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"remove_unused_symbols","","Removes unused symbols.",21,{"inputs":[{"name":"remap"}],"output":null}],[11,"reorder_symbols","","Remaps symbols to satisfy given ordering constraints. The argument\nmust be a function that gives total order.",21,{"inputs":[{"name":"remap"},{"name":"f"}],"output":null}],[11,"get_mapping","","Get the mapping.",21,{"inputs":[{"name":"remap"}],"output":{"name":"mapping"}}],[11,"new","","Creates a new instance of `Mapping`.",20,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"translate","","Translates symbols in this map using another symbol map.\nThis map becomes a combination of both mappings.",20,{"inputs":[{"name":"mapping"},{"name":"self"}],"output":null}],[0,"rule","cfg","This module defines grammar rules. Each rule in a context-free grammar\nconsists of a single symbol on its left-hand side and an array of symbols\non its right-hand side. In this library, each rule carries additional\nvalue called &quot;history.&quot;",null,null],[3,"Rule","cfg::rule","Typical grammar rule representation.",null,null],[12,"rhs","","The rule&#39;s right-hand side.",22,null],[12,"history","","The rule&#39;s history.",22,null],[3,"RuleRef","","References rule&#39;s components.",null,null],[12,"lhs","","Left-hand side.",23,null],[12,"rhs","","Right-hand side.",23,null],[12,"history","","The rule&#39;s history.",23,null],[0,"builder","","Grammar rules can be built with the builder pattern.",null,null],[3,"RuleBuilder","cfg::rule::builder","The rule builder.",null,null],[11,"new","","Creates a rule builder.",24,{"inputs":[{"name":"c"}],"output":{"name":"rulebuilder"}}],[11,"default_history","","Sets the default history source.",24,{"inputs":[{"name":"rulebuilder"},{"name":"hs2"}],"output":{"name":"rulebuilder"}}],[11,"rule","","Starts building a new rule with the given LHS.",24,{"inputs":[{"name":"rulebuilder"},{"name":"symbol"}],"output":{"name":"self"}}],[11,"history","","Assigns the rule history, which is used on the next call to `rhs`, or overwritten by a call\nto`rhs_with_history`.",24,{"inputs":[{"name":"rulebuilder"},{"name":"history"}],"output":{"name":"self"}}],[11,"rhs","","Adds a rule alternative to the grammar. If history wasn&#39;t provided, the rule has the\n`Default` history.",24,{"inputs":[{"name":"rulebuilder"},{"name":"sr"}],"output":{"name":"self"}}],[11,"rhs_with_history","","Adds a rule alternative with the given RHS and history to the grammar.",24,{"inputs":[{"name":"rulebuilder"},{"name":"sr"},{"name":"history"}],"output":{"name":"self"}}],[11,"precedenced_rule","","Starts building a new precedenced rule.",24,{"inputs":[{"name":"rulebuilder"},{"name":"symbol"}],"output":{"name":"precedencedrulebuilder"}}],[0,"container","cfg::rule","Abstraction for collections of rules.",null,null],[8,"RuleContainer","cfg::rule::container","Trait for rule and symbol containers.",null,null],[16,"History","","The type of history carried with the rule.",25,null],[10,"sym_source","","Returns an immutable reference to the grammar&#39;s symbol source.",25,{"inputs":[{"name":"rulecontainer"}],"output":{"name":"symbolsource"}}],[10,"sym_source_mut","","Returns a mutable reference to the grammar&#39;s symbol source.",25,{"inputs":[{"name":"rulecontainer"}],"output":{"name":"symbolsource"}}],[11,"sym","","Returns generated symbols.",25,{"inputs":[{"name":"rulecontainer"}],"output":{"name":"t"}}],[11,"next_sym","","Generates a new unique symbol.",25,{"inputs":[{"name":"rulecontainer"}],"output":{"name":"symbol"}}],[11,"num_syms","","Returns the number of symbols in use.",25,{"inputs":[{"name":"rulecontainer"}],"output":{"name":"usize"}}],[10,"retain","","Retains only the rules specified by the predicate.",25,{"inputs":[{"name":"rulecontainer"},{"name":"f"}],"output":null}],[10,"add_rule","","Inserts a rule with `lhs` and `rhs` on its LHS and RHS. The rule carries `history`.",25,null],[8,"GrammarRule","cfg::rule","Trait for rules of a context-free grammar.",null,null],[16,"History","","The type of history carried with the rule.",26,null],[10,"lhs","","Returns the rule&#39;s left-hand side.",26,{"inputs":[{"name":"grammarrule"}],"output":{"name":"symbol"}}],[10,"rhs","","Returns the rule&#39;s right-hand side.",26,null],[10,"history","","Returns a reference to the history carried with the rule.",26,{"inputs":[{"name":"grammarrule"}],"output":{"name":"history"}}],[11,"fmt","","",22,{"inputs":[{"name":"rule"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",22,{"inputs":[{"name":"rule"}],"output":{"name":"rule"}}],[11,"lhs","","",22,{"inputs":[{"name":"rule"}],"output":{"name":"symbol"}}],[11,"rhs","","",22,null],[11,"history","","",22,{"inputs":[{"name":"rule"}],"output":{"name":"h"}}],[11,"new","","Creates a new rule.",22,{"inputs":[{"name":"symbol"},{"name":"vec"},{"name":"h"}],"output":{"name":"self"}}],[11,"clone","","",23,{"inputs":[{"name":"ruleref"}],"output":{"name":"self"}}],[11,"lhs","","",23,{"inputs":[{"name":"ruleref"}],"output":{"name":"symbol"}}],[11,"rhs","","",23,null],[11,"history","","",23,{"inputs":[{"name":"ruleref"}],"output":{"name":"h"}}],[0,"sequence","cfg","Sequences are similar to regex repetitions with numbering.",null,null],[3,"Sequence","cfg::sequence","Sequence rule representation.",null,null],[12,"lhs","","The rule&#39;s left-hand side.",27,null],[12,"rhs","","The rule&#39;s right-hand side.",27,null],[12,"start","","The minimum number of repetitions.",27,null],[12,"end","","Either the inclusive maximum number of repetitions, or `None` if the number of repetitions\nis unlimited.",27,null],[12,"separator","","The way elements are separated in a sequence, or `Null`.",27,null],[12,"history","","The history carried with the sequence rule.",27,null],[4,"Separator","","The separator symbol and mode of separation in a sequence, or `Null` for no separation.",null,null],[13,"Trailing","","Separation with the trailing separator included. In other words, all elements are followed\nby the separator.",28,null],[13,"Proper","","The separator occurs between elements.",28,null],[13,"Liberal","","The union of `Trailing` and `Proper`. In other words, the trailing separator may or may not\nbe present.",28,null],[13,"Null","","No separation.",28,null],[0,"builder","","Sequence rules can be built with the builder pattern.",null,null],[3,"SequenceRuleBuilder","cfg::sequence::builder","Sequence rule builder.",null,null],[11,"new","","Creates a sequence rule builder.",29,{"inputs":[{"name":"d"}],"output":{"name":"self"}}],[11,"default_history","","Sets the default history source.",29,{"inputs":[{"name":"sequencerulebuilder"},{"name":"hs2"}],"output":{"name":"sequencerulebuilder"}}],[11,"sequence","","Starts building a sequence rule.",29,{"inputs":[{"name":"sequencerulebuilder"},{"name":"symbol"}],"output":{"name":"self"}}],[11,"separator","","Assigns the separator symbol and mode of separation.",29,{"inputs":[{"name":"sequencerulebuilder"},{"name":"separator"}],"output":{"name":"self"}}],[11,"intersperse","","Sets proper separation with the given separator symbol.",29,{"inputs":[{"name":"sequencerulebuilder"},{"name":"symbol"}],"output":{"name":"self"}}],[11,"history","","Assigns the rule history, which is used on the next call to `rhs`, or overwritten by a call\nto `rhs_with_history`.",29,{"inputs":[{"name":"sequencerulebuilder"},{"name":"h"}],"output":{"name":"self"}}],[11,"inclusive","","Assigns the inclusive range of the number of repetitions.",29,{"inputs":[{"name":"sequencerulebuilder"},{"name":"u32"},{"name":"option"}],"output":{"name":"self"}}],[11,"rhs","","Adds a sequence rule to the grammar.",29,{"inputs":[{"name":"sequencerulebuilder"},{"name":"symbol"}],"output":{"name":"self"}}],[11,"rhs_with_history","","Adds a sequence rule to the grammar.",29,{"inputs":[{"name":"sequencerulebuilder"},{"name":"symbol"},{"name":"h"}],"output":{"name":"self"}}],[0,"destination","cfg::sequence","Sequence destination.",null,null],[8,"SequenceDestination","cfg::sequence::destination","Trait for storing sequence rules in containers, with potential rewrites.",null,null],[10,"add_sequence","","Inserts a sequence rule.",30,{"inputs":[{"name":"sequencedestination"},{"name":"sequence"}],"output":null}],[0,"rewrite","cfg::sequence","Rewrites sequence rules into production rules.",null,null],[3,"SequencesToProductions","cfg::sequence::rewrite","Rewrites sequence rules into production rules.",null,null],[11,"add_sequence","","",31,{"inputs":[{"name":"sequencestoproductions"},{"name":"sequence"}],"output":null}],[11,"new","","Initializes a rewrite.",31,{"inputs":[{"name":"d"}],"output":{"name":"self"}}],[11,"rewrite_sequences","","Rewrites sequence rules.",31,null],[11,"rewrite","","Rewrites a sequence rule.",31,{"inputs":[{"name":"sequencestoproductions"},{"name":"sequence"}],"output":null}],[11,"eq","cfg::sequence","",27,{"inputs":[{"name":"sequence"},{"name":"sequence"}],"output":{"name":"bool"}}],[11,"ne","","",27,{"inputs":[{"name":"sequence"},{"name":"sequence"}],"output":{"name":"bool"}}],[11,"hash","","",27,null],[11,"fmt","","",27,{"inputs":[{"name":"sequence"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",27,{"inputs":[{"name":"sequence"}],"output":{"name":"sequence"}}],[11,"eq","","",28,{"inputs":[{"name":"separator"},{"name":"separator"}],"output":{"name":"bool"}}],[11,"ne","","",28,{"inputs":[{"name":"separator"},{"name":"separator"}],"output":{"name":"bool"}}],[11,"hash","","",28,null],[11,"fmt","","",28,{"inputs":[{"name":"separator"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",28,{"inputs":[{"name":"separator"}],"output":{"name":"separator"}}],[11,"inclusive","","Assigns the inclusive range of the number of repetitions.",27,{"inputs":[{"name":"sequence"},{"name":"u32"},{"name":"option"}],"output":{"name":"self"}}],[11,"separator","","Assigns the separator symbol and mode of separation.",27,{"inputs":[{"name":"sequence"},{"name":"separator"}],"output":{"name":"self"}}],[11,"prefix_separator","","Returns the kind of separation for a prefix sequence.",28,{"inputs":[{"name":"separator"}],"output":{"name":"self"}}],[11,"into","","",28,{"inputs":[{"name":"separator"}],"output":{"name":"option"}}],[0,"symbol","cfg","A type that can represent symbols in a context-free grammar. Symbols are distinguished by their\nIDs.",null,null],[3,"Symbol","cfg::symbol","A common grammar symbol type.",null,null],[11,"partial_cmp","cfg","",32,{"inputs":[{"name":"symbol"},{"name":"symbol"}],"output":{"name":"option"}}],[11,"lt","","",32,{"inputs":[{"name":"symbol"},{"name":"symbol"}],"output":{"name":"bool"}}],[11,"le","","",32,{"inputs":[{"name":"symbol"},{"name":"symbol"}],"output":{"name":"bool"}}],[11,"gt","","",32,{"inputs":[{"name":"symbol"},{"name":"symbol"}],"output":{"name":"bool"}}],[11,"ge","","",32,{"inputs":[{"name":"symbol"},{"name":"symbol"}],"output":{"name":"bool"}}],[11,"eq","","",32,{"inputs":[{"name":"symbol"},{"name":"symbol"}],"output":{"name":"bool"}}],[11,"ne","","",32,{"inputs":[{"name":"symbol"},{"name":"symbol"}],"output":{"name":"bool"}}],[11,"cmp","","",32,{"inputs":[{"name":"symbol"},{"name":"symbol"}],"output":{"name":"ordering"}}],[11,"hash","","",32,null],[11,"fmt","","",32,{"inputs":[{"name":"symbol"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",32,{"inputs":[{"name":"symbol"}],"output":{"name":"symbol"}}],[11,"from","","",32,{"inputs":[{"name":"symbolrepr"}],"output":{"name":"self"}}],[11,"into","","",32,{"inputs":[{"name":"symbol"}],"output":{"name":"symbolrepr"}}],[0,"set","cfg::symbol","Informs whether symbols are terminal or nonterminal.",null,null],[3,"SymbolBitSet","cfg::symbol::set","A set of symbols in the form of a bit vector.",null,null],[3,"Iter","","An iterator over a symbol set.",null,null],[11,"new","","Constructs a `SymbolBitSet`.",33,{"inputs":[{"name":"g"},{"name":"bool"}],"output":{"name":"self"}}],[11,"terminal_set","","Gathers information about whether symbols are terminal or nonterminal.\nConstructs a set of terminal symbols.",33,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"has_sym","","Checks whether a given symbol is in this set.",33,{"inputs":[{"name":"symbolbitset"},{"name":"symbol"}],"output":{"name":"bool"}}],[11,"into_bit_vec","","Converts into a bit vector.",33,{"inputs":[{"name":"symbolbitset"}],"output":{"name":"bitvec"}}],[11,"iter","","Iterates over symbols in the set.",33,{"inputs":[{"name":"symbolbitset"}],"output":{"name":"iter"}}],[11,"next","","",34,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[0,"source","cfg::symbol","Source",null,null],[3,"SymbolSource","cfg::symbol::source","A source of numeric symbols.",null,null],[3,"Generate","","Iterator for generating symbols.",null,null],[8,"SymbolContainer","","Trait used to generate symbols.",null,null],[10,"generate","","Generates symbols.",35,{"inputs":[{"name":"symbolsource"}],"output":{"name":"self"}}],[11,"fmt","","",36,{"inputs":[{"name":"symbolsource"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",36,{"inputs":[{"name":"symbolsource"}],"output":{"name":"symbolsource"}}],[11,"new","","Creates a source of numeric symbols with an empty symbol space.",36,{"inputs":[],"output":{"name":"self"}}],[11,"sym","","Returns generated symbols.",36,{"inputs":[{"name":"symbolsource"}],"output":{"name":"t"}}],[11,"next_sym","","Generates a new unique symbol.",36,{"inputs":[{"name":"symbolsource"}],"output":{"name":"symbol"}}],[11,"num_syms","","Returns the number of symbols in use.",36,{"inputs":[{"name":"symbolsource"}],"output":{"name":"usize"}}],[11,"generate","","Returns an iterator that generates symbols.",36,{"inputs":[{"name":"symbolsource"}],"output":{"name":"generate"}}],[11,"generate","cfg","",32,{"inputs":[{"name":"symbolsource"}],"output":{"name":"self"}}],[11,"next","cfg::symbol::source","",37,{"inputs":[{"name":"generate"}],"output":{"name":"option"}}],[11,"usize","cfg","Cast the symbol&#39;s ID to `usize`.",32,{"inputs":[{"name":"symbol"}],"output":{"name":"usize"}}],[11,"from","","",32,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"into","","",32,{"inputs":[{"name":"symbol"}],"output":{"name":"usize"}}],[0,"usefulness","","Analysis of rule usefulness.",null,null],[3,"Usefulness","cfg::usefulness","Contains the information about usefulness of the grammar&#39;s rules.\nUseful rules are both reachable and productive.",null,null],[3,"UselessRules","","An iterator over the grammar&#39;s useless rules.",null,null],[3,"UselessRule","","A reference to a useless rule, together with the reason for its uselessness.",null,null],[12,"rule","","Reference to a rule.",38,null],[12,"unreachable","","Indicates whether the rule is unreachable.",38,null],[12,"unproductive","","Indicates whether the rule is unproductive.",38,null],[11,"fmt","","",38,{"inputs":[{"name":"uselessrule"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",38,{"inputs":[{"name":"uselessrule"}],"output":{"name":"uselessrule"}}],[11,"new","","Analyzes usefulness of the grammar&#39;s rules. In particular, it checks for reachable\nand productive symbols.",39,{"inputs":[{"name":"g"}],"output":{"name":"usefulness"}}],[11,"productivity","","Checks whether a symbol is productive. Can be used to determine the precise reason\nof a rule&#39;s unproductiveness.",39,{"inputs":[{"name":"usefulness"},{"name":"symbol"}],"output":{"name":"bool"}}],[11,"reachable","","Sets symbol reachability. Takes an array of reachable symbols.",39,{"inputs":[{"name":"usefulness"},{"name":"sr"}],"output":{"name":"self"}}],[11,"all_useful","","Checks whether all rules in the grammar are useful.",39,{"inputs":[{"name":"usefulness"}],"output":{"name":"bool"}}],[11,"all_productive","","Checks whether all rules in the grammar are productive.",39,{"inputs":[{"name":"usefulness"}],"output":{"name":"bool"}}],[11,"useless_rules","","Returns an iterator over the grammar&#39;s useless rules.",39,{"inputs":[{"name":"usefulness"}],"output":{"name":"uselessrules"}}],[11,"remove_useless_rules","","Removes useless rules. The language represented by the grammar doesn&#39;t change.",39,{"inputs":[{"name":"usefulness"}],"output":null}],[11,"next","","",40,{"inputs":[{"name":"uselessrules"}],"output":{"name":"option"}}],[8,"ContextFree","cfg","Trait for context-free grammars.",null,null],[11,"rule","","Starts building a new rule.",41,{"inputs":[{"name":"contextfree"},{"name":"symbol"}],"output":{"name":"rulebuilder"}}],[11,"precedenced_rule","","Starts building a new precedenced rule.",41,{"inputs":[{"name":"contextfree"},{"name":"symbol"}],"output":{"name":"precedencedrulebuilder"}}],[8,"ContextFreeRef","","This trait is currently needed to make the associated `Rules` iterator generic over a lifetime\nparameter.",null,null],[16,"RuleRef","","Immutable reference to a rule.",42,null],[16,"Rules","","Iterator over immutable references to the grammar&#39;s rules.",42,null],[10,"rules","","Returns an iterator over immutable references to the grammar&#39;s rules.",42,{"inputs":[{"name":"contextfreeref"}],"output":{"name":"rules"}}],[8,"ContextFreeMut","","Allows access to a ContextFreeRef through mutable references.",null,null],[11,"rule","","Starts building a new rule.",41,{"inputs":[{"name":"contextfree"},{"name":"symbol"}],"output":{"name":"rulebuilder"}}],[11,"precedenced_rule","","Starts building a new precedenced rule.",41,{"inputs":[{"name":"contextfree"},{"name":"symbol"}],"output":{"name":"precedencedrulebuilder"}}]],"paths":[[3,"BinarizedCfg"],[3,"Cycles"],[3,"CycleParticipants"],[3,"Cfg"],[4,"BinarizedRhsSubset"],[8,"Action"],[8,"Binarize"],[8,"EliminateNulling"],[8,"AssignPrecedence"],[8,"RewriteSequence"],[8,"HistorySource"],[3,"NullHistory"],[3,"CloneHistory"],[3,"DefaultHistory"],[3,"NullHistorySource"],[4,"Associativity"],[3,"PrecedencedRuleBuilder"],[3,"MinimalDistance"],[3,"FirstSets"],[3,"FollowSets"],[3,"Mapping"],[3,"Remap"],[3,"Rule"],[3,"RuleRef"],[3,"RuleBuilder"],[8,"RuleContainer"],[8,"GrammarRule"],[3,"Sequence"],[4,"Separator"],[3,"SequenceRuleBuilder"],[8,"SequenceDestination"],[3,"SequencesToProductions"],[3,"Symbol"],[3,"SymbolBitSet"],[3,"Iter"],[8,"SymbolContainer"],[3,"SymbolSource"],[3,"Generate"],[3,"UselessRule"],[3,"Usefulness"],[3,"UselessRules"],[8,"ContextFree"],[8,"ContextFreeRef"]]};
searchIndex["bit_matrix"] = {"doc":"Implements bit matrices.","items":[[0,"matrix","bit_matrix","Matrix of bits.",null,null],[3,"BitMatrix","bit_matrix::matrix","A matrix of bits.",null,null],[11,"hash","","",0,null],[11,"cmp","","",0,{"inputs":[{"name":"bitmatrix"},{"name":"bitmatrix"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"bitmatrix"},{"name":"bitmatrix"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"bitmatrix"},{"name":"bitmatrix"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"bitmatrix"},{"name":"bitmatrix"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"bitmatrix"},{"name":"bitmatrix"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"bitmatrix"},{"name":"bitmatrix"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"bitmatrix"},{"name":"bitmatrix"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"bitmatrix"},{"name":"bitmatrix"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"bitmatrix"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"bitmatrix"}],"output":{"name":"bitmatrix"}}],[11,"new","","Create a new BitMatrix with specific numbers of bits in columns and rows.",0,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"size","","Returns the matrix&#39;s size as `(rows, columns)`.",0,null],[11,"set","","Sets the value of a bit.",0,{"inputs":[{"name":"bitmatrix"},{"name":"usize"},{"name":"usize"},{"name":"bool"}],"output":null}],[11,"grow","","Grows the matrix in-place, adding `num_rows` rows filled with `value`.",0,{"inputs":[{"name":"bitmatrix"},{"name":"usize"},{"name":"bool"}],"output":null}],[11,"sub_matrix","","Returns a slice of the matrix&#39;s rows.",0,{"inputs":[{"name":"bitmatrix"},{"name":"range"}],"output":{"name":"bitsubmatrix"}}],[11,"split_at","","Given a row&#39;s index, returns a slice of all rows above that row, a reference to said row,\nand a slice of all rows below.",0,null],[11,"split_at_mut","","Given a row&#39;s index, returns a slice of all rows above that row, a reference to said row,\nand a slice of all rows below.",0,null],[11,"iter_row","","Iterate over bits in the specified row.",0,{"inputs":[{"name":"bitmatrix"},{"name":"usize"}],"output":{"name":"iter"}}],[11,"transitive_closure","","Computes the transitive closure of the binary relation represented by the matrix.",0,{"inputs":[{"name":"bitmatrix"}],"output":null}],[11,"index","","",0,{"inputs":[{"name":"bitmatrix"},{"name":"usize"}],"output":{"name":"bitvecslice"}}],[11,"index_mut","","",0,{"inputs":[{"name":"bitmatrix"},{"name":"usize"}],"output":{"name":"bitvecslice"}}],[11,"index","","",0,null],[0,"row","bit_matrix","Implements access to a matrix&#39;s individual rows.",null,null],[3,"BitVecSlice","bit_matrix::row","A slice of bit vector&#39;s blocks.",null,null],[3,"Iter","","An iterator for `BitVecSlice`.",null,null],[11,"new","","Creates a new slice from a slice of blocks.",1,null],[11,"iter_bits","","Iterates over bits.",1,{"inputs":[{"name":"bitvecslice"},{"name":"usize"}],"output":{"name":"iter"}}],[11,"get","","Returns `true` if a bit is enabled in the bit vector slice, or `false` otherwise.",1,{"inputs":[{"name":"bitvecslice"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"index","","",1,{"inputs":[{"name":"bitvecslice"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"deref","","",1,null],[11,"deref_mut","","",1,null],[11,"clone","","",2,{"inputs":[{"name":"iter"}],"output":{"name":"iter"}}],[11,"next","","",2,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"size_hint","","",2,null],[0,"submatrix","bit_matrix","Submatrix of bits.",null,null],[3,"BitSubMatrix","bit_matrix::submatrix","Immutable access to a range of matrix&#39;s rows.",null,null],[3,"BitSubMatrixMut","","Mutable access to a range of matrix&#39;s rows.",null,null],[11,"new","","Returns a new BitSubMatrix.",3,null],[11,"from_raw_parts","","Forms a BitSubMatrix from a pointer and dimensions.",3,null],[11,"iter","","Iterates over the matrix&#39;s rows in the form of mutable slices.",3,{"inputs":[{"name":"bitsubmatrix"}],"output":{"name":"map"}}],[11,"new","","Returns a new BitSubMatrixMut.",4,null],[11,"from_raw_parts","","Forms a BitSubMatrix from a pointer and dimensions.",4,null],[11,"set","","Sets the value of a bit.",4,{"inputs":[{"name":"bitsubmatrixmut"},{"name":"usize"},{"name":"usize"},{"name":"bool"}],"output":null}],[11,"sub_matrix","","Returns a slice of the matrix&#39;s rows.",4,{"inputs":[{"name":"bitsubmatrixmut"},{"name":"range"}],"output":{"name":"bitsubmatrix"}}],[11,"split_at","","Given a row&#39;s index, returns a slice of all rows above that row, a reference to said row,\nand a slice of all rows below.",4,null],[11,"split_at_mut","","Given a row&#39;s index, returns a slice of all rows above that row, a reference to said row,\nand a slice of all rows below.",4,null],[11,"transitive_closure","","Computes the transitive closure of the binary relation represented by the matrix.",4,{"inputs":[{"name":"bitsubmatrixmut"}],"output":null}],[11,"iter_mut","","Iterates over the matrix&#39;s rows in the form of mutable slices.",4,{"inputs":[{"name":"bitsubmatrixmut"}],"output":{"name":"map"}}],[11,"index","","",4,{"inputs":[{"name":"bitsubmatrixmut"},{"name":"usize"}],"output":{"name":"bitvecslice"}}],[11,"index_mut","","",4,{"inputs":[{"name":"bitsubmatrixmut"},{"name":"usize"}],"output":{"name":"bitvecslice"}}],[11,"index","","",3,{"inputs":[{"name":"bitsubmatrix"},{"name":"usize"}],"output":{"name":"bitvecslice"}}],[11,"fmt","","",3,{"inputs":[{"name":"bitsubmatrix"},{"name":"formatter"}],"output":{"name":"result"}}],[6,"Block","bit_matrix","The type for storing bits.",null,null],[7,"TRUE","","A value for borrowing.",null,null],[7,"FALSE","","A value for borrowing.",null,null],[17,"BITS","","The number of bits in a block.",null,null]],"paths":[[3,"BitMatrix"],[3,"BitVecSlice"],[3,"Iter"],[3,"BitSubMatrix"],[3,"BitSubMatrixMut"]]};
searchIndex["optional"] = {"doc":"Space-efficient optional values","items":[[3,"IterBool","optional","",null,null],[3,"Optioned","","An `Option&lt;T&gt;`-like structure that takes only as much space as the enclosed\nvalue, at the cost of removing one particular `None` value from the value\ndomain (see `Noned`)",null,null],[3,"OptionedIter","","",null,null],[4,"OptionBool","","The `OptionBool` type, a space-efficient Option&lt;bool&gt; replacement",null,null],[13,"SomeTrue","","Some(true)",0,null],[13,"SomeFalse","","Some(false)",0,null],[13,"None","","None",0,null],[5,"some","","Create an `Optioned&lt;T&gt;` that is `some(t)`.",null,{"inputs":[{"name":"t"}],"output":{"name":"optioned"}}],[5,"none","","Create a `None Optioned&lt;T&gt;`. Note that the type must be inferrible\n from the context, or you&#39;d need to call with `::&lt;T&gt;` where `T` is\n the specific type.",null,{"inputs":[],"output":{"name":"optioned"}}],[5,"wrap","","Wrap a `T` into an `Optioned&lt;T&gt;`, regardless of its None-ness.",null,{"inputs":[{"name":"t"}],"output":{"name":"optioned"}}],[8,"Noned","","A trait whose implementation for any type `T` allows the use of\n`Optioned&lt;T&gt;` where `T` is bound by both `Sized` and `Copy`.",null,null],[10,"is_none","","Returns `true` if the contained value is the declared `None` for `T`,\n`false` otherwise.",1,{"inputs":[{"name":"noned"}],"output":{"name":"bool"}}],[10,"get_none","","Returns the declared `None` value for `T`.",1,{"inputs":[],"output":{"name":"self"}}],[8,"OptEq","","Equality within Optioned",null,null],[10,"opt_eq","","",2,{"inputs":[{"name":"opteq"},{"name":"self"}],"output":{"name":"bool"}}],[8,"OptOrd","","Ordering within Optioned",null,null],[10,"opt_cmp","","",3,{"inputs":[{"name":"optord"},{"name":"self"}],"output":{"name":"ordering"}}],[11,"hash","","",0,null],[11,"cmp","","",0,{"inputs":[{"name":"optionbool"},{"name":"optionbool"}],"output":{"name":"ordering"}}],[11,"clone","","",0,{"inputs":[{"name":"optionbool"}],"output":{"name":"optionbool"}}],[11,"is_some","core::option","Returns `true` if the option is a `Some` value",4,{"inputs":[{"name":"option"}],"output":{"name":"bool"}}],[11,"is_none","","Returns `true` if the option is a `None` value",4,{"inputs":[{"name":"option"}],"output":{"name":"bool"}}],[11,"as_ref","","Converts from `Option&lt;T&gt;` to `Option&lt;&amp;T&gt;`",4,{"inputs":[{"name":"option"}],"output":{"name":"option"}}],[11,"as_mut","","Converts from `Option&lt;T&gt;` to `Option&lt;&amp;mut T&gt;`",4,{"inputs":[{"name":"option"}],"output":{"name":"option"}}],[11,"expect","","Unwraps an option, yielding the content of a `Some`.",4,{"inputs":[{"name":"option"},{"name":"str"}],"output":{"name":"t"}}],[11,"unwrap","","Moves the value `v` out of the `Option&lt;T&gt;` if it is `Some(v)`.",4,{"inputs":[{"name":"option"}],"output":{"name":"t"}}],[11,"unwrap_or","","Returns the contained value or a default.",4,{"inputs":[{"name":"option"},{"name":"t"}],"output":{"name":"t"}}],[11,"unwrap_or_else","","Returns the contained value or computes it from a closure.",4,{"inputs":[{"name":"option"},{"name":"f"}],"output":{"name":"t"}}],[11,"map","","Maps an `Option&lt;T&gt;` to `Option&lt;U&gt;` by applying a function to a contained value",4,{"inputs":[{"name":"option"},{"name":"f"}],"output":{"name":"option"}}],[11,"map_or","","Applies a function to the contained value (if any),\nor returns a `default` (if not).",4,{"inputs":[{"name":"option"},{"name":"u"},{"name":"f"}],"output":{"name":"u"}}],[11,"map_or_else","","Applies a function to the contained value (if any),\nor computes a `default` (if not).",4,{"inputs":[{"name":"option"},{"name":"d"},{"name":"f"}],"output":{"name":"u"}}],[11,"ok_or","","Transforms the `Option&lt;T&gt;` into a `Result&lt;T, E&gt;`, mapping `Some(v)` to\n`Ok(v)` and `None` to `Err(err)`.",4,{"inputs":[{"name":"option"},{"name":"e"}],"output":{"name":"result"}}],[11,"ok_or_else","","Transforms the `Option&lt;T&gt;` into a `Result&lt;T, E&gt;`, mapping `Some(v)` to\n`Ok(v)` and `None` to `Err(err())`.",4,{"inputs":[{"name":"option"},{"name":"f"}],"output":{"name":"result"}}],[11,"iter","","Returns an iterator over the possibly contained value.",4,{"inputs":[{"name":"option"}],"output":{"name":"iter"}}],[11,"iter_mut","","Returns a mutable iterator over the possibly contained value.",4,{"inputs":[{"name":"option"}],"output":{"name":"itermut"}}],[11,"and","","Returns `None` if the option is `None`, otherwise returns `optb`.",4,{"inputs":[{"name":"option"},{"name":"option"}],"output":{"name":"option"}}],[11,"and_then","","Returns `None` if the option is `None`, otherwise calls `f` with the\nwrapped value and returns the result.",4,{"inputs":[{"name":"option"},{"name":"f"}],"output":{"name":"option"}}],[11,"or","","Returns the option if it contains a value, otherwise returns `optb`.",4,{"inputs":[{"name":"option"},{"name":"option"}],"output":{"name":"option"}}],[11,"or_else","","Returns the option if it contains a value, otherwise calls `f` and\nreturns the result.",4,{"inputs":[{"name":"option"},{"name":"f"}],"output":{"name":"option"}}],[11,"take","","Takes the value out of the option, leaving a `None` in its place.",4,{"inputs":[{"name":"option"}],"output":{"name":"option"}}],[11,"cloned","","Maps an `Option&lt;&amp;T&gt;` to an `Option&lt;T&gt;` by cloning the contents of the\noption.",4,{"inputs":[{"name":"option"}],"output":{"name":"option"}}],[11,"unwrap_or_default","","Returns the contained value or a default",4,{"inputs":[{"name":"option"}],"output":{"name":"t"}}],[11,"from_iter","","Takes each element in the `Iterator`: if it is `None`, no further\nelements are taken, and the `None` is returned. Should no `None` occur, a\ncontainer with the values of each `Option` is returned.",4,{"inputs":[{"name":"i"}],"output":{"name":"option"}}],[11,"into_iter","","Returns a consuming iterator over the possibly contained value.",4,{"inputs":[{"name":"option"}],"output":{"name":"intoiter"}}],[11,"default","","",4,{"inputs":[],"output":{"name":"option"}}],[11,"clone","","",4,{"inputs":[{"name":"option"}],"output":{"name":"option"}}],[11,"eq","","",4,{"inputs":[{"name":"option"},{"name":"option"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"option"},{"name":"option"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",4,{"inputs":[{"name":"option"},{"name":"option"}],"output":{"name":"option"}}],[11,"lt","","",4,{"inputs":[{"name":"option"},{"name":"option"}],"output":{"name":"bool"}}],[11,"le","","",4,{"inputs":[{"name":"option"},{"name":"option"}],"output":{"name":"bool"}}],[11,"gt","","",4,{"inputs":[{"name":"option"},{"name":"option"}],"output":{"name":"bool"}}],[11,"ge","","",4,{"inputs":[{"name":"option"},{"name":"option"}],"output":{"name":"bool"}}],[11,"cmp","","",4,{"inputs":[{"name":"option"},{"name":"option"}],"output":{"name":"ordering"}}],[11,"fmt","","",4,{"inputs":[{"name":"option"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",4,null],[11,"deref","optional","",0,{"inputs":[{"name":"optionbool"}],"output":{"name":"option"}}],[11,"eq","","",0,{"inputs":[{"name":"optionbool"},{"name":"optionbool"}],"output":{"name":"bool"}}],[11,"index","","",0,null],[11,"partial_cmp","","",0,{"inputs":[{"name":"optionbool"},{"name":"optionbool"}],"output":{"name":"option"}}],[11,"some","","Create a SomeTrue for true, SomeFalse for false",0,{"inputs":[{"name":"bool"}],"output":{"name":"self"}}],[11,"none","","Create a None value.",0,{"inputs":[],"output":{"name":"self"}}],[11,"is_some","","Returns true if the option is a Some value.",0,{"inputs":[{"name":"optionbool"}],"output":{"name":"bool"}}],[11,"is_none","","Returns true if the option is a Some value.",0,{"inputs":[{"name":"optionbool"}],"output":{"name":"bool"}}],[11,"expect","","Unwraps the contained bool, panics on None with given message.",0,{"inputs":[{"name":"optionbool"},{"name":"str"}],"output":{"name":"bool"}}],[11,"unwrap","","Unwraps the contained bool, panics on None.",0,{"inputs":[{"name":"optionbool"}],"output":{"name":"bool"}}],[11,"unwrap_or","","Returns the contained bool or a default.",0,{"inputs":[{"name":"optionbool"},{"name":"bool"}],"output":{"name":"bool"}}],[11,"unwrap_or_else","","Returns the contained bool or a computed default.",0,{"inputs":[{"name":"optionbool"},{"name":"f"}],"output":{"name":"bool"}}],[11,"map","","Maps an `OptionBool` to an `Option&lt;U&gt;` by applying the function\n over the contained bool.",0,{"inputs":[{"name":"optionbool"},{"name":"f"}],"output":{"name":"option"}}],[11,"map_bool","","Maps an `OptionBool` to another `OptionBool` by applying the\n function over the contained bool.",0,{"inputs":[{"name":"optionbool"},{"name":"f"}],"output":{"name":"optionbool"}}],[11,"map_or","","Maps a value to a `U` by applying the function or return a\n default `U`.",0,{"inputs":[{"name":"optionbool"},{"name":"u"},{"name":"f"}],"output":{"name":"u"}}],[11,"map_or_else","","Maps a value to a `U` by applying the function or return a\n computed default.",0,{"inputs":[{"name":"optionbool"},{"name":"d"},{"name":"f"}],"output":{"name":"u"}}],[11,"ok_or","","Transforms the `OptionBool` into a `Result&lt;bool, E&gt;`, mapping\n `Some`X to `Ok(`X`)` and `None` to `Err(err)`.",0,{"inputs":[{"name":"optionbool"},{"name":"e"}],"output":{"name":"result"}}],[11,"ok_or_else","","Transforms the `OptionBool` into a `Result&lt;bool, E&gt;`, mapping `Some`X to\n `Ok(`X`)` and `None` to a calculated `Err(err)`.",0,{"inputs":[{"name":"optionbool"},{"name":"f"}],"output":{"name":"result"}}],[11,"and","","Returns `None` if the option is `None`, otherwise returns `optb`.",0,{"inputs":[{"name":"optionbool"},{"name":"option"}],"output":{"name":"option"}}],[11,"and_bool","","Returns `None` if the option is `None`, otherwise returns `optb`.",0,{"inputs":[{"name":"optionbool"},{"name":"optionbool"}],"output":{"name":"optionbool"}}],[11,"and_then","","returns `None` if the `OptionBool` is `None`, otherwise calls `f` with\n the boolean value and returns the result as an `Option&lt;U&gt;`",0,{"inputs":[{"name":"optionbool"},{"name":"f"}],"output":{"name":"option"}}],[11,"and_then_bool","","returns `None` if the `OptionBool` is `None`, otherwise calls `f` with\n the boolean value and returns the result as an `OptionBool`",0,{"inputs":[{"name":"optionbool"},{"name":"f"}],"output":{"name":"optionbool"}}],[11,"or","","Returns this as Option unless this is `None`, in which case returns\n `optb`.",0,{"inputs":[{"name":"optionbool"},{"name":"option"}],"output":{"name":"option"}}],[11,"or_bool","","Returns this as Option unless this is `None`, in which case returns\n `optb`.",0,{"inputs":[{"name":"optionbool"},{"name":"optionbool"}],"output":{"name":"optionbool"}}],[11,"or_else","","Returns this as Option unless this is `None`, in which case use the\n supplied function to calculate the result.",0,{"inputs":[{"name":"optionbool"},{"name":"f"}],"output":{"name":"option"}}],[11,"or_else_bool","","Returns this as Option unless this is `None`, in which case use the\n supplied function to calculate the result.",0,{"inputs":[{"name":"optionbool"},{"name":"f"}],"output":{"name":"optionbool"}}],[11,"iter","","return an iterator over all contained (that is zero or one) values.",0,{"inputs":[{"name":"optionbool"}],"output":{"name":"iter"}}],[11,"as_slice","","return a possibly empty slice with the contained value, if any.",0,null],[11,"take","","Takes the value out of the `OptionBool` and returns ist as\n `Option&lt;bool&gt;`, changing self to `None`.",0,{"inputs":[{"name":"optionbool"}],"output":{"name":"option"}}],[11,"take_bool","","Takes the value out of the `OptionBool`, changing self to `None`.",0,{"inputs":[{"name":"optionbool"}],"output":{"name":"optionbool"}}],[11,"fmt","","",0,{"inputs":[{"name":"optionbool"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next","","",5,{"inputs":[{"name":"iterbool"}],"output":{"name":"option"}}],[11,"into_iter","","",0,{"inputs":[{"name":"optionbool"}],"output":{"name":"iterbool"}}],[11,"default","","",0,{"inputs":[],"output":{"name":"optionbool"}}],[11,"from","core::option","",4,{"inputs":[{"name":"optionbool"}],"output":{"name":"option"}}],[11,"from","","",4,{"inputs":[{"name":"optionbool"}],"output":{"name":"option"}}],[11,"from","optional","",0,{"inputs":[{"name":"option"}],"output":{"name":"self"}}],[11,"from","","",0,{"inputs":[{"name":"option"}],"output":{"name":"self"}}],[11,"clone","","",6,{"inputs":[{"name":"optioned"}],"output":{"name":"optioned"}}],[11,"eq","","",6,{"inputs":[{"name":"optioned"},{"name":"self"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",6,{"inputs":[{"name":"optioned"},{"name":"self"}],"output":{"name":"option"}}],[11,"cmp","","",6,{"inputs":[{"name":"optioned"},{"name":"self"}],"output":{"name":"ordering"}}],[11,"hash","","",6,{"inputs":[{"name":"optioned"},{"name":"h"}],"output":null}],[11,"some","","Create an `Optioned&lt;T&gt;` that is `some(t)`.",6,{"inputs":[{"name":"t"}],"output":{"name":"self"}}],[11,"none","","Create an `Optioned&lt;T&gt;` that is `none()`.",6,{"inputs":[],"output":{"name":"self"}}],[11,"is_none","","Returns `true` if this `Optioned` is `None`, `false` otherwise.",6,{"inputs":[{"name":"optioned"}],"output":{"name":"bool"}}],[11,"is_some","","Returns `true` if this `Optioned` contains a value, `false` otherwise.",6,{"inputs":[{"name":"optioned"}],"output":{"name":"bool"}}],[11,"expect","","Unwraps the value, if any, else panics with the given message.",6,{"inputs":[{"name":"optioned"},{"name":"str"}],"output":{"name":"t"}}],[11,"unwrap","","Unwraps the value, if any, else panics with &quot;unwrap called on None&quot;.",6,{"inputs":[{"name":"optioned"}],"output":{"name":"t"}}],[11,"unpack","","Returns the contained value, even if None.",6,{"inputs":[{"name":"optioned"}],"output":{"name":"t"}}],[11,"unwrap_or","","Returns the contained value or a default.",6,{"inputs":[{"name":"optioned"},{"name":"t"}],"output":{"name":"t"}}],[11,"unwrap_or_else","","Returns the contained value or a calculated default.",6,{"inputs":[{"name":"optioned"},{"name":"f"}],"output":{"name":"t"}}],[11,"map","","Maps the `Optioned` to an `Option&lt;U&gt;` by applying the function over the\n contained value, if any.",6,{"inputs":[{"name":"optioned"},{"name":"f"}],"output":{"name":"option"}}],[11,"map_t","","Maps the `Optioned&lt;T&gt;` to an `Optioned&lt;U&gt;` by applying the function over\n the contained value, if any. Requires that the result type of the\n function be `Noned + Copy`, as other types aren&#39;t compatible with\n Optioned.",6,{"inputs":[{"name":"optioned"},{"name":"f"}],"output":{"name":"optioned"}}],[11,"map_or","","Maps the contained value to a `U` by applying the function or return a\n default.",6,{"inputs":[{"name":"optioned"},{"name":"u"},{"name":"f"}],"output":{"name":"u"}}],[11,"map_or_else","","Maps a value to a `U` by applying the function or return a computed\n default.",6,{"inputs":[{"name":"optioned"},{"name":"d"},{"name":"f"}],"output":{"name":"u"}}],[11,"take","","Takes the value out of the `Optioned` and returns ist as\n `Option&lt;T&gt;`, changing self to `None`.",6,{"inputs":[{"name":"optioned"}],"output":{"name":"option"}}],[11,"as_slice","","Return a possibly empty slice over the contained value, if any.",6,null],[11,"iter","","return an iterator over all contained (that is zero or one) values.",6,{"inputs":[{"name":"optioned"}],"output":{"name":"optionediter"}}],[11,"fmt","","",6,{"inputs":[{"name":"optioned"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",6,{"inputs":[],"output":{"name":"optioned"}}],[11,"clone","","",7,{"inputs":[{"name":"optionediter"}],"output":{"name":"optionediter"}}],[11,"next","","",7,{"inputs":[{"name":"optionediter"}],"output":{"name":"option"}}],[11,"from","","",6,{"inputs":[{"name":"option"}],"output":{"name":"optioned"}}],[11,"from","","",6,{"inputs":[{"name":"option"}],"output":{"name":"optioned"}}],[11,"into","","",6,{"inputs":[{"name":"optioned"}],"output":{"name":"option"}}]],"paths":[[4,"OptionBool"],[8,"Noned"],[8,"OptEq"],[8,"OptOrd"],[4,"Option"],[3,"IterBool"],[3,"Optioned"],[3,"OptionedIter"]]};
searchIndex["bit_vec"] = {"doc":"Collections implemented with bit vectors.","items":[[3,"BitVec","bit_vec","The bitvector type.",null,null],[3,"Iter","","An iterator for `BitVec`.",null,null],[3,"IntoIter","","",null,null],[3,"Blocks","","An iterator over the blocks of a `BitVec`.",null,null],[8,"BitBlock","","Abstracts over a pile of bits (basically unsigned primitives)",null,null],[10,"bits","","How many bits it has",0,{"inputs":[],"output":{"name":"usize"}}],[11,"bytes","","How many bytes it has",0,{"inputs":[],"output":{"name":"usize"}}],[10,"from_byte","","Convert a byte into this type (lowest-order bits set)",0,{"inputs":[{"name":"u8"}],"output":{"name":"self"}}],[10,"count_ones","","Count the number of 1&#39;s in the bitwise repr",0,{"inputs":[{"name":"bitblock"}],"output":{"name":"usize"}}],[10,"zero","","Get `0`",0,{"inputs":[],"output":{"name":"self"}}],[10,"one","","Get `1`",0,{"inputs":[],"output":{"name":"self"}}],[11,"index","","",1,{"inputs":[{"name":"bitvec"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"new","","Creates an empty `BitVec`.",1,{"inputs":[],"output":{"name":"self"}}],[11,"from_elem","","Creates a `BitVec` that holds `nbits` elements, setting each element\nto `bit`.",1,{"inputs":[{"name":"usize"},{"name":"bool"}],"output":{"name":"self"}}],[11,"with_capacity","","Constructs a new, empty `BitVec` with the specified capacity.",1,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"from_bytes","","Transforms a byte-vector into a `BitVec`. Each byte becomes eight bits,\nwith the most significant bits of each byte coming first. Each\nbit becomes `true` if equal to 1 or `false` if equal to 0.",1,null],[11,"from_fn","","Creates a `BitVec` of the specified length where the value at each index\nis `f(index)`.",1,{"inputs":[{"name":"usize"},{"name":"f"}],"output":{"name":"self"}}],[11,"blocks","","Iterator over the underlying blocks of data",1,{"inputs":[{"name":"bitvec"}],"output":{"name":"blocks"}}],[11,"storage","","Exposes the raw block storage of this BitVec",1,null],[11,"storage_mut","","Exposes the raw block storage of this BitVec",1,{"inputs":[{"name":"bitvec"}],"output":{"name":"vec"}}],[11,"get","","Retrieves the value at index `i`, or `None` if the index is out of bounds.",1,{"inputs":[{"name":"bitvec"},{"name":"usize"}],"output":{"name":"option"}}],[11,"set","","Sets the value of a bit at an index `i`.",1,{"inputs":[{"name":"bitvec"},{"name":"usize"},{"name":"bool"}],"output":null}],[11,"set_all","","Sets all bits to 1.",1,{"inputs":[{"name":"bitvec"}],"output":null}],[11,"negate","","Flips all bits.",1,{"inputs":[{"name":"bitvec"}],"output":null}],[11,"union","","Calculates the union of two bitvectors. This acts like the bitwise `or`\nfunction.",1,{"inputs":[{"name":"bitvec"},{"name":"self"}],"output":{"name":"bool"}}],[11,"intersect","","Calculates the intersection of two bitvectors. This acts like the\nbitwise `and` function.",1,{"inputs":[{"name":"bitvec"},{"name":"self"}],"output":{"name":"bool"}}],[11,"difference","","Calculates the difference between two bitvectors.",1,{"inputs":[{"name":"bitvec"},{"name":"self"}],"output":{"name":"bool"}}],[11,"all","","Returns `true` if all bits are 1.",1,{"inputs":[{"name":"bitvec"}],"output":{"name":"bool"}}],[11,"iter","","Returns an iterator over the elements of the vector in order.",1,{"inputs":[{"name":"bitvec"}],"output":{"name":"iter"}}],[11,"none","","Returns `true` if all bits are 0.",1,{"inputs":[{"name":"bitvec"}],"output":{"name":"bool"}}],[11,"any","","Returns `true` if any bit is 1.",1,{"inputs":[{"name":"bitvec"}],"output":{"name":"bool"}}],[11,"to_bytes","","Organises the bits into bytes, such that the first bit in the\n`BitVec` becomes the high-order bit of the first byte. If the\nsize of the `BitVec` is not a multiple of eight then trailing bits\nwill be filled-in with `false`.",1,{"inputs":[{"name":"bitvec"}],"output":{"name":"vec"}}],[11,"eq_vec","","Compares a `BitVec` to a slice of `bool`s.\nBoth the `BitVec` and slice must have the same length.",1,null],[11,"truncate","","Shortens a `BitVec`, dropping excess elements.",1,{"inputs":[{"name":"bitvec"},{"name":"usize"}],"output":null}],[11,"reserve","","Reserves capacity for at least `additional` more bits to be inserted in the given\n`BitVec`. The collection may reserve more space to avoid frequent reallocations.",1,{"inputs":[{"name":"bitvec"},{"name":"usize"}],"output":null}],[11,"reserve_exact","","Reserves the minimum capacity for exactly `additional` more bits to be inserted in the\ngiven `BitVec`. Does nothing if the capacity is already sufficient.",1,{"inputs":[{"name":"bitvec"},{"name":"usize"}],"output":null}],[11,"capacity","","Returns the capacity in bits for this bit vector. Inserting any\nelement less than this amount will not trigger a resizing.",1,{"inputs":[{"name":"bitvec"}],"output":{"name":"usize"}}],[11,"grow","","Grows the `BitVec` in-place, adding `n` copies of `value` to the `BitVec`.",1,{"inputs":[{"name":"bitvec"},{"name":"usize"},{"name":"bool"}],"output":null}],[11,"pop","","Removes the last bit from the BitVec, and returns it. Returns None if the BitVec is empty.",1,{"inputs":[{"name":"bitvec"}],"output":{"name":"option"}}],[11,"push","","Pushes a `bool` onto the end.",1,{"inputs":[{"name":"bitvec"},{"name":"bool"}],"output":null}],[11,"len","","Returns the total number of bits in this vector",1,{"inputs":[{"name":"bitvec"}],"output":{"name":"usize"}}],[11,"set_len","","Sets the number of bits that this BitVec considers initialized.",1,{"inputs":[{"name":"bitvec"},{"name":"usize"}],"output":null}],[11,"is_empty","","Returns true if there are no bits in this vector",1,{"inputs":[{"name":"bitvec"}],"output":{"name":"bool"}}],[11,"clear","","Clears all bits in this vector.",1,{"inputs":[{"name":"bitvec"}],"output":null}],[11,"default","","",1,{"inputs":[],"output":{"name":"self"}}],[11,"from_iter","","",1,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend","","",1,{"inputs":[{"name":"bitvec"},{"name":"i"}],"output":null}],[11,"clone","","",1,{"inputs":[{"name":"bitvec"}],"output":{"name":"self"}}],[11,"clone_from","","",1,{"inputs":[{"name":"bitvec"},{"name":"self"}],"output":null}],[11,"partial_cmp","","",1,{"inputs":[{"name":"bitvec"},{"name":"self"}],"output":{"name":"option"}}],[11,"cmp","","",1,{"inputs":[{"name":"bitvec"},{"name":"self"}],"output":{"name":"ordering"}}],[11,"fmt","","",1,{"inputs":[{"name":"bitvec"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"hash","","",1,{"inputs":[{"name":"bitvec"},{"name":"h"}],"output":null}],[11,"eq","","",1,{"inputs":[{"name":"bitvec"},{"name":"self"}],"output":{"name":"bool"}}],[11,"clone","","",2,{"inputs":[{"name":"iter"}],"output":{"name":"iter"}}],[11,"next","","",2,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"size_hint","","",2,null],[11,"next_back","","",2,{"inputs":[{"name":"iter"}],"output":{"name":"option"}}],[11,"next","","",3,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"next_back","","",3,{"inputs":[{"name":"intoiter"}],"output":{"name":"option"}}],[11,"into_iter","","",1,{"inputs":[{"name":"bitvec"}],"output":{"name":"intoiter"}}],[11,"clone","","",4,{"inputs":[{"name":"blocks"}],"output":{"name":"blocks"}}],[11,"next","","",4,{"inputs":[{"name":"blocks"}],"output":{"name":"option"}}],[11,"size_hint","","",4,null],[11,"next_back","","",4,{"inputs":[{"name":"blocks"}],"output":{"name":"option"}}]],"paths":[[8,"BitBlock"],[3,"BitVec"],[3,"Iter"],[3,"IntoIter"],[3,"Blocks"]]};
searchIndex["typed_arena"] = {"doc":"The arena, a fast but limited type of allocator.","items":[[3,"Arena","typed_arena","",null,null],[11,"new","","",0,{"inputs":[],"output":{"name":"arena"}}],[11,"with_capacity","","",0,{"inputs":[{"name":"usize"}],"output":{"name":"arena"}}],[11,"alloc","","Allocates a value in the arena, and returns a mutable reference\nto that value.",0,{"inputs":[{"name":"arena"},{"name":"t"}],"output":{"name":"t"}}],[11,"alloc_extend","","Uses the contents of an iterator to allocate values in the arena.\nReturns a mutable slice that contains these values.",0,null],[11,"alloc_uninitialized","","Allocates space for a given number of values, but doesn&#39;t initialize it.",0,null],[11,"uninitialized_array","","Returns unused space.",0,null],[11,"into_vec","","",0,{"inputs":[{"name":"arena"}],"output":{"name":"vec"}}]],"paths":[[3,"Arena"]]};
searchIndex["ref_slice"] = {"doc":"","items":[[5,"ref_slice","ref_slice","Converts a reference to A into a slice of length 1 (without copying).",null,null],[5,"mut_ref_slice","","Converts a reference to A into a slice of length 1 (without copying).",null,null],[5,"opt_slice","","Converts a reference to Option&lt;A&gt; into a slice of length 0 or 1 (without copying).",null,null],[5,"mut_opt_slice","","Converts a reference to Option&lt;A&gt; into a slice of length 0 or 1 (without copying).",null,null]],"paths":[]};
initSearch(searchIndex);
